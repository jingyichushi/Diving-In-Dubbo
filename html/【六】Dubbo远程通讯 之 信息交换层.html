
<!-- saved from url=(0371)http://localhost:63342/ead61b63-b0a6-4ff2-a49a-86be75ccfd1a/source?file=%2FUsers%2Flrq%2FWorkspace%2Ftech_research_deeply%2Fdubbo%2F%E3%80%90%E5%85%AD%E3%80%91Dubbo%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF+%E4%B9%8B+%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E5%B1%82.adoc&mac=j+5uvIl8C2WNF0xvHLU1F8cgvGgdkCgN7oMP2Gj8PH0=&projectUrl=%2FUsers%2Flrq%2FWorkspace%2Ftech_research_deeply -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid currentColor;opacity:.35;padding:0 .5em 0 0}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}

</style>
<link rel="stylesheet" href="res_files/css/font-awesome.min.css"><link rel="stylesheet" href="res_files/css/dejavu.css"><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head><body><div id="MathJax_Message" style="display: none;"></div><div id="content">
<h1>Dubbo远程通讯 · 信息交换层</h1>
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock has-source-line data-line-stdin-3">
<blockquote>
<div class="paragraph has-source-line data-line-stdin-5">
<p><code>请求-响应</code>是一种面向网络的通讯模式，由一台主机响应另一台主机的特定数据请求，通常，在发送完整的消息之前有一系列这样的交换而这通常是基于在
两个应用程序通过一个通道进行的双向对话。</p>
</div>
</blockquote>
</div>
<div class="paragraph has-source-line data-line-stdin-9">
<p>由上述表述可以看出，平常所熟悉的<code>请求-响应</code>模式表面上是一问一答的，实际一个应答背后可能对应着多个交互往来，另外其通讯是基于双向通道的。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-11">
<p>Dubbo将端到端的网络通讯相关的行为封装网络传输层<sup><strong>Transporter</strong></sup>，具体的网络I/O则委托给了类似Netty等的网络通讯中间件，而更关注业务语义的
信息交换行为则抽象成<code>Exchanger</code>置于会话层中，官方文档中有如下表述，说明其关注重点是<span class="big">一问一答</span>。为了单位时间能够获得更大的吞吐量
避免同步阻塞产生不必要的资源浪费，Dubbo在这一个抽象层中完成了同步转异步的操作。</p>
</div>
<div class="quoteblock has-source-line data-line-stdin-14">
<blockquote>
<div class="paragraph has-source-line data-line-stdin-16">
<p><strong>exchange信息交换层</strong>： 封装 请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel,
ExchangeClient, ExchangeServer</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1 has-source-line data-line-stdin-20">
<h2 id="_transporter层基础"><strong>Transporter</strong>层基础</h2>
<div class="sectionbody">
<div class="sect2 has-source-line data-line-stdin-22">
<h3 id="_实现方式介绍">实现方式介绍</h3>
<div class="paragraph has-source-line data-line-stdin-24">
<p>相对Dubbo的网络传输层，这一层所涉及实现细节及复杂度均小很多，如下UML图所示，上半截的<code>Endpoint、Channel、Client、Server、ChannelHandler</code>等均已
在传输层定义和实现，而下半截的<code>ExchangeChannel、ExchangeClient、ExchangeServer、ExchangeChannelHandler</code>这几个关键组件则是在当前交换层
定义的，实现方式几乎是沿袭传输层且一一对应的，上一层是对下一层的封装和增强，当前层只聚焦于其业务实现所需，这是分层模式思想的精髓。</p>
</div>
<div class="imageblock has-source-line data-line-stdin-28">
<div class="content">
<img src="res_files/imgs/6_image" alt="Dubbo Exchange UML" width="650">
</div>
<div class="title">图：Dubbo Exchange UML</div>
</div>
<div class="paragraph has-source-line data-line-stdin-30">
<p>依然，Client和Channel的一对一绑定关系，Client的行为直接委托给当前连接的Channel实现，因此如下两个<code>同步转异步</code>的操作被定义在<code>ExchangeChannel</code>
中。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-34">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">ExchangeChannel</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Channel</span> {

    <span style="color:#777">// send request.</span>
    CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; request(<span style="color:#0a8;font-weight:bold">Object</span> request)
        <span style="color:#088;font-weight:bold">throws</span> RemotingException;

    <span style="color:#777">// send request.</span>
    CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; request(<span style="color:#0a8;font-weight:bold">Object</span> request, <span style="color:#339;font-weight:bold">int</span> timeout)
        <span style="color:#088;font-weight:bold">throws</span> RemotingException;

}</code></pre>
</div>
</div>
<div class="paragraph has-source-line data-line-stdin-49">
<p>信息交换层和传输层的关系，最直观的表示如下图，入站的请求或响应数据流总是经由交换层转入传输层，出站的响应或请求则反之。</p>
</div>
<div class="imageblock has-source-line data-line-stdin-51">
<div class="content">
<img src="res_files/imgs/6_image(1)" alt="Dubbo Framework Remoting" width="650">
</div>
<div class="title">图：Dubbo Framework Remoting</div>
</div>
<div class="paragraph has-source-line data-line-stdin-53">
<p>对应Dubbo中的具体实现方式是类的继承关系，如<code>ExchangeChannel</code>表达的是交换层的行为，其父类<code>Channel</code>表达的是更为底层的传输层行为，因此
该层大多接口定义的方法行为实际上已由其扩展的接口定义，通过一些类型的强制转换手段可以达到同样的效果，当然不能就此认为这些定义多余，从语义上来说
这些定义确保了该层的行为完整性，使之更加符合分层架构的风格，获取该层定义相关对象也更加便利。具体如下述代码：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-58">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeaderExchangeChannel</span> <span style="color:#088;font-weight:bold">implements</span> ExchangeChannel {
    ...
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> ChannelHandler getChannelHandler() {
        <span style="color:#080;font-weight:bold">return</span> channel.getChannelHandler();
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> ExchangeHandler getExchangeHandler() {
        <span style="color:#080;font-weight:bold">return</span> (ExchangeHandler) channel.getChannelHandler();
    }
    ...
}

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeaderExchangeServer</span> <span style="color:#088;font-weight:bold">implements</span> ExchangeServer {
    ...
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">Collection</span>&lt;ExchangeChannel&gt; getExchangeChannels() {
        <span style="color:#0a8;font-weight:bold">Collection</span>&lt;ExchangeChannel&gt; exchangeChannels =
            <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>&lt;ExchangeChannel&gt;();

        <span style="color:#0a8;font-weight:bold">Collection</span>&lt;<span style="color:#0a8;font-weight:bold">Channel</span>&gt; channels = server.getChannels();
        <span style="color:#080;font-weight:bold">if</span> (CollectionUtils.isNotEmpty(channels)) {
            <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">Channel</span> channel : channels) {
                exchangeChannels.add(
                    HeaderExchangeChannel.getOrAddChannel(channel));
            }
        }
        <span style="color:#080;font-weight:bold">return</span> exchangeChannels;
    }

    <span style="color:#777">//ExchangeChannel → Channel</span>
    <span style="color:#007">@Override</span>
    <span style="color:#007">@SuppressWarnings</span>({<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">unchecked</span><span style="color:#710">"</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">rawtypes</span><span style="color:#710">"</span></span>})
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">Collection</span>&lt;<span style="color:#0a8;font-weight:bold">Channel</span>&gt; getChannels() {
        <span style="color:#080;font-weight:bold">return</span> (<span style="color:#0a8;font-weight:bold">Collection</span>) getExchangeChannels();
    }

    <span style="color:#777">//ExchangeChannel → Channel</span>
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">Channel</span> getChannel(<span style="color:#0a8;font-weight:bold">InetSocketAddress</span> remoteAddress) {
        <span style="color:#080;font-weight:bold">return</span> getExchangeChannel(remoteAddress);
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> ExchangeChannel getExchangeChannel(<span style="color:#0a8;font-weight:bold">InetSocketAddress</span> remoteAddress) {
        <span style="color:#0a8;font-weight:bold">Channel</span> channel = server.getChannel(remoteAddress);
        <span style="color:#080;font-weight:bold">return</span> HeaderExchangeChannel.getOrAddChannel(channel);
    }
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2 has-source-line data-line-stdin-113">
<h3 id="_request_response_核心模型定义"><strong>Request</strong> / <strong>Response</strong> 核心模型定义</h3>
<table class="tableblock frame-all grid-all stretch has-source-line data-line-stdin-118">
<caption class="title">Table 1. <strong>Request</strong> / <strong>Response</strong></caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">Request</th>
<th class="tableblock halign-left valign-top">Response</th>
<th class="tableblock halign-left valign-top">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">final long <strong>mId</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>会话ID，Response的ID来自对应的Request，计算方式：AtomicLong.getAndIncrement()</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String <strong>mVersion</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>版本号，实际上是当前所使用的Dubbo环境的Dubbo RPC protocol version，由<span class="big"> <code>Version.getProtocolVersion()</code> </span>取得</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean <strong>mEvent</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>心跳、只读 事件标识</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> HEARTBEAT_EVENT = <span style="color:#069">null</span>, READONLY_EVENT = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">R</span><span style="color:#710">"</span></span>;

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> setEvent(<span style="color:#0a8;font-weight:bold">String</span> event) {
    <span style="color:#950">this</span>.mEvent = <span style="color:#069">true</span>;
    <span style="color:#950">this</span>.mData = event;
}

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">boolean</span> isHeartbeat() {
    <span style="color:#080;font-weight:bold">return</span> mEvent &amp;&amp; HEARTBEAT_EVENT == mData;
}

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> setHeartbeat(<span style="color:#339;font-weight:bold">boolean</span> isHeartbeat) {
    <span style="color:#080;font-weight:bold">if</span> (isHeartbeat) {
        setEvent(HEARTBEAT_EVENT);
    }
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean <strong>mTwoWay</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✘</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>双向标识，若为true，在一段收到请求后，需要给对方回应一个应答，让对方确认我方已经收到请求，根据当前处理状态发回对应的响应，存在正常、异常、
心跳3种响应</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean <strong>mBroken</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✘</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>请求发送到对方后，由Netty等还原成Request对象，如果对方在解码环节过程中遇到异常，便会设置该标识，由其他handler根据该标识做进一步处理。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object <strong>mData</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✘</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>封装请求内容的数据容器，可以是任何Java类型的对象</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>String HEARTBEAT_EVENT = null</code>  mData的值为null值时被认为是心跳事件</p>
</li>
<li>
<p><code>String READONLY_EVENT = "R"</code>  mData的值为“R”则说明服务器端整处于正在关闭中的状态，不再执行有关写操作等。</p>
</li>
</ol>
</div>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object <strong>mResult</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>封装响应内容的数据容器，可以是任何Java类型的对象</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byte <strong>mStatus</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>响应状态，总共有如下10种状态</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">byte</span> OK = <span style="color:#00D">20</span>,<span style="color:#777">//ok.</span>

    CLIENT_TIMEOUT = <span style="color:#00D">30</span>,<span style="color:#777">//client side timeout.</span>

    SERVER_TIMEOUT = <span style="color:#00D">31</span>,<span style="color:#777">//server side timeout.</span>

    CHANNEL_INACTIVE = <span style="color:#00D">35</span>,<span style="color:#777">//channel inactive, directly return the unfinished requests.</span>

    BAD_REQUEST = <span style="color:#00D">40</span>,<span style="color:#777">//request format error.</span>

    BAD_RESPONSE = <span style="color:#00D">50</span>,<span style="color:#777">//response format error.</span>

    SERVICE_NOT_FOUND = <span style="color:#00D">60</span>,<span style="color:#777">//service not found.</span>

    SERVICE_ERROR = <span style="color:#00D">70</span>,<span style="color:#777">//service error.</span>

    SERVER_ERROR = <span style="color:#00D">80</span>,<span style="color:#777">//internal server error.</span>

    CLIENT_ERROR = <span style="color:#00D">90</span>,<span style="color:#777">//internal server error.</span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String <strong>mErrorMsg</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✔</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>可读错误响应消息，返回给请求方</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2 has-source-line data-line-stdin-214">
<h3 id="_周期任务">周期任务</h3>
<div class="paragraph has-source-line data-line-stdin-216">
<p>因Dubbo需要时刻检查当前自身的相关组件的状态，多出出现周期定时任务的身影，本序列文章的开始就介绍了Dubbo的定时轮算法。在Exchanger这个框架层
中有如下三种类型的定时任务：</p>
</div>
<div class="olist arabic has-source-line data-line-stdin-219">
<ol class="arabic">
<li class="has-source-line data-line-stdin-219">
<p><strong>Client 心跳</strong>：Client总是定期的给对方发送心跳事件，维持长联状态；</p>
<div class="literalblock has-source-line data-line-stdin-221">
<div class="content">
<pre>通道上最近读操作或写操作距当前时间已经超过一个心跳周期</pre>
</div>
</div>
</li>
<li class="has-source-line data-line-stdin-223">
<p><strong>Client 重连</strong>：Client定期检测当前所持Channel通道是否掉线，掉线则重连；</p>
<div class="literalblock has-source-line data-line-stdin-225">
<div class="content">
<pre>通道已经处于掉线状态，或者最近读操作已经超过最大允许闲置时间</pre>
</div>
</div>
</li>
<li class="has-source-line data-line-stdin-227">
<p><strong>Server 下线处理</strong>：为避免接入Client方由于宕机或断电后后还持有其连接Channel通道产生资源浪费，Server会定期轮询连入Channel的状态，若有一段
时间未发生读写事件，则将其剔除处理——<code>close()</code>。</p>
<div class="literalblock has-source-line data-line-stdin-230">
<div class="content">
<pre>通道上最近读操作或写操作距当前时间已经超过最大闲置允许时间</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph has-source-line data-line-stdin-233">
<p>本文不在赘述定时轮算法相关原理或机制，简要说明具体应用依据。在<a href="http://localhost:63342/ead61b63-b0a6-4ff2-a49a-86be75ccfd1a/source?file=%2FUsers%2Flrq%2FWorkspace%2Ftech_research_deeply%2Fdubbo%2F%E3%80%90%E5%85%AD%E3%80%91Dubbo%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF+%E4%B9%8B+%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E5%B1%82.adoc&amp;mac=j+5uvIl8C2WNF0xvHLU1F8cgvGgdkCgN7oMP2Gj8PH0=&amp;projectUrl=%2FUsers%2Flrq%2FWorkspace%2Ftech_research_deeply#Dubbo%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%20%C2%B7%20%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82">[Dubbo远程通讯 · 网络传输层]</a>这一文中已经提到，Dubbo实现的通道Channel持有一个
缓存通道本地环境变量的键值对Map，当前层在I/O回调事件发生时，会向其中写入<code>HeaderExchangeHandler</code>中的读写时间戳<code>KEY_READ_TIMESTAMP</code>和
<code>KEY_WRITE_TIMESTAMP</code>，周期定时任务只要根据实现需求执行对应检查处理便可。它们和I/O回调事件的关系如下：</p>
</div>
<div class="ulist has-source-line data-line-stdin-237">
<ul>
<li class="has-source-line data-line-stdin-237">
<p><strong>KEY_READ_TIMESTAMP</strong>：<code>connected、received</code></p>
</li>
<li class="has-source-line data-line-stdin-238">
<p><strong>KEY_WRITE_TIMESTAMP</strong>：<code>connected、sent</code></p>
</li>
</ul>
</div>
<div class="paragraph has-source-line data-line-stdin-240">
<p><code>disconnected</code>回调则会清除这些时间戳标识。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-242">
<p>注：<span class="small">另外每次心跳触发的I/O回调事件也会执行同样的读写时间戳的写入操作，当然通道断连后，无需处理<code>disconnected</code>回调。</span></p>
</div>
<div class="paragraph has-source-line data-line-stdin-244">
<p>最近读写时间戳的实现是通过装饰器类<code>HeartbeatHandler</code>实现的，机制是通过它在绑定于Client或Server上的Channel的回调网络I/O事件，根据事件
类型对应写入读或者写时间戳。对于<code>received</code>回调，如果判别到对方发送的是心跳请求，在对方<code>isTwoWay()</code>的特性基础上会发送一个心跳响应回去，
心跳响应则只会简单打印日志。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-249">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeartbeatHandler</span> <span style="color:#088;font-weight:bold">extends</span> AbstractChannelHandlerDelegate {

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Logger</span> logger = LoggerFactory.getLogger(HeartbeatHandler.class);

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> KEY_READ_TIMESTAMP = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">READ_TIMESTAMP</span><span style="color:#710">"</span></span>;

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> KEY_WRITE_TIMESTAMP = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">WRITE_TIMESTAMP</span><span style="color:#710">"</span></span>;

    <span style="color:#088;font-weight:bold">public</span> HeartbeatHandler(ChannelHandler handler) {
        <span style="color:#950">super</span>(handler);
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> connected(<span style="color:#0a8;font-weight:bold">Channel</span> channel) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        setReadTimestamp(channel);
        setWriteTimestamp(channel);
        handler.connected(channel);
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> disconnected(<span style="color:#0a8;font-weight:bold">Channel</span> channel) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        clearReadTimestamp(channel);
        clearWriteTimestamp(channel);
        handler.disconnected(channel);
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> sent(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Object</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        setWriteTimestamp(channel);
        handler.sent(channel, message);
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> received(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Object</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        setReadTimestamp(channel);
        <span style="color:#080;font-weight:bold">if</span> (isHeartbeatRequest(message)) {
            Request req = (Request) message;
            <span style="color:#080;font-weight:bold">if</span> (req.isTwoWay()) {
                Response res = <span style="color:#080;font-weight:bold">new</span> Response(req.getId(), req.getVersion());
                res.setEvent(Response.HEARTBEAT_EVENT);
                channel.send(res);
                <span style="color:#080;font-weight:bold">if</span> (logger.isInfoEnabled()) {
                    <span style="color:#339;font-weight:bold">int</span> heartbeat = channel.getUrl().getParameter(Constants.HEARTBEAT_KEY, <span style="color:#00D">0</span>);
                    <span style="color:#080;font-weight:bold">if</span> (logger.isDebugEnabled()) {
                        logger.debug(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Received heartbeat from remote channel </span><span style="color:#710">"</span></span> + channel.getRemoteAddress()
                                + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, cause: The channel has no data-transmission exceeds a heartbeat period</span><span style="color:#710">"</span></span>
                                + (heartbeat &gt; <span style="color:#00D">0</span> ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">: </span><span style="color:#710">"</span></span> + heartbeat + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">ms</span><span style="color:#710">"</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#710">"</span></span>));
                    }
                }
            }
            <span style="color:#080;font-weight:bold">return</span>;
        }
        <span style="color:#080;font-weight:bold">if</span> (isHeartbeatResponse(message)) {
            <span style="color:#080;font-weight:bold">if</span> (logger.isDebugEnabled()) {
                logger.debug(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Receive heartbeat response in thread </span><span style="color:#710">"</span></span> + <span style="color:#0a8;font-weight:bold">Thread</span>.currentThread().getName());
            }
            <span style="color:#080;font-weight:bold">return</span>;
        }
        handler.received(channel, message);
    }

    ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note has-source-line data-line-stdin-315">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>KEY_READ_TIMESTAMP</code> 和 <code>KEY_WRITE_TIMESTAMP</code> 这两个Channel本地属性除了用在<code>HeartbeatHandler</code>，也在<code>HeaderExchangeHandler</code>
被用到，为啥会被两个<code>ChannelHandler</code>网络I/O事件回调器使用？因为是后者会被所有Dubbo支持的网络I/O中间的支持，但前者则取决于他们是否有能力
支持心跳机制，也即<code>IdleSensible</code>，不支持的情况下只会在Client端启用<code>ReconnectTimerTask</code>周期定时重连任务。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3 has-source-line data-line-stdin-321">
<h4 id="_定时轮应用细节">定时轮应用细节</h4>
<div class="paragraph has-source-line data-line-stdin-323">
<p>URL是所有Dubbo的关键组件的配置总线，有关其配置都是需要单独维护和使用的，因此这里的心跳周期时长和闲置时长都是从URL中获取到的。Dubbo中相关时机
计算方式如下：</p>
</div>
<div class="olist arabic has-source-line data-line-stdin-326">
<ol class="arabic">
<li class="has-source-line data-line-stdin-326">
<p>Client端每1/3心跳周期时段检测是否需要发送心跳包；</p>
</li>
<li class="has-source-line data-line-stdin-327">
<p>每1/3心跳周期时段服务端或客户端检测是否需要关闭连接或执行重连处理。</p>
</li>
</ol>
</div>
<div class="paragraph has-source-line data-line-stdin-330">
<p><span class="small">闲置超时时长，默认是<code>3 × 心跳周期</code>，最少为<code>2 × 心跳周期</code>，客户端的和服务端的检测均是按同一个周期执行的，假定服务端结束一个
周期的时间，客户端的恰好刚刚已经开始，如果客户端按小于两个周期时间执行超时计算，则会错过客户端的断连后的重试操作。</span></p>
</div>
<div class="listingblock has-source-line data-line-stdin-334">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#777">//============================</span>
<span style="color:#777">//DEFAULT_HEARTBEAT：1m，默认的心跳周期时长。</span>
<span style="color:#777">//============================</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">UrlUtils</span> {
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">int</span> getIdleTimeout(<span style="color:#0a8;font-weight:bold">URL</span> url) {
        <span style="color:#339;font-weight:bold">int</span> heartBeat = getHeartbeat(url);
        <span style="color:#777">// idleTimeout should be at least more than twice heartBeat because possible retries of client.</span>
        <span style="color:#339;font-weight:bold">int</span> idleTimeout = url.getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartBeat * <span style="color:#00D">3</span>);
        <span style="color:#080;font-weight:bold">if</span> (idleTimeout &lt; heartBeat * <span style="color:#00D">2</span>) {
            <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">IllegalStateException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">idleTimeout &lt; heartbeatInterval * 2</span><span style="color:#710">"</span></span>);
        }
        <span style="color:#080;font-weight:bold">return</span> idleTimeout;
    }

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">int</span> getHeartbeat(<span style="color:#0a8;font-weight:bold">URL</span> url) {
        <span style="color:#080;font-weight:bold">return</span> url.getParameter(Constants.HEARTBEAT_KEY, Constants.DEFAULT_HEARTBEAT);
    }
}

<span style="color:#777">//============================</span>
<span style="color:#777">//HEARTBEAT_CHECK_TICK：值为3。</span>
<span style="color:#777">//LEAST_HEARTBEAT_DURATION：1000ms，默认的最少间隔周期时长。但最终取决于客户端或服务端配置</span>
<span style="color:#777">//============================</span>
<span style="color:#777">/**
 * Each interval cannot be less than 1000ms.
 */</span>
<span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">long</span> calculateLeastDuration(<span style="color:#339;font-weight:bold">int</span> time) {
    <span style="color:#080;font-weight:bold">if</span> (time / HEARTBEAT_CHECK_TICK &lt;= <span style="color:#00D">0</span>) {
        <span style="color:#080;font-weight:bold">return</span> LEAST_HEARTBEAT_DURATION;
    } <span style="color:#080;font-weight:bold">else</span> {
        <span style="color:#080;font-weight:bold">return</span> time / HEARTBEAT_CHECK_TICK;
    }
}

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeaderExchangeClient</span> <span style="color:#088;font-weight:bold">implements</span> ExchangeClient {
...

    private <span style="color:#339;font-weight:bold">void</span> startHeartBeatTask(<span style="color:#0a8;font-weight:bold">URL</span> url) {
        <span style="color:#080;font-weight:bold">if</span> (!client.canHandleIdle()) {
            AbstractTimerTask.ChannelProvider cp = () -&gt;
                <span style="color:#0a8;font-weight:bold">Collections</span>.singletonList(HeaderExchangeClient.this);

            <span style="color:#777">//根据配置总线中解析心跳周期时长</span>
            <span style="color:#339;font-weight:bold">int</span> heartbeat = getHeartbeat(url);
            <span style="color:#339;font-weight:bold">long</span> heartbeatTick = calculateLeastDuration(heartbeat);
            <span style="color:#950">this</span>.heartBeatTimerTask = <span style="color:#080;font-weight:bold">new</span> HeartbeatTimerTask(cp, heartbeatTick, heartbeat);
            IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, <span style="color:#0a8;font-weight:bold">TimeUnit</span>.MILLISECONDS);
        }
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">void</span> startReconnectTask(<span style="color:#0a8;font-weight:bold">URL</span> url) {
        <span style="color:#080;font-weight:bold">if</span> (shouldReconnect(url)) {
            AbstractTimerTask.ChannelProvider cp = () -&gt;
                <span style="color:#0a8;font-weight:bold">Collections</span>.singletonList(HeaderExchangeClient.this);

            <span style="color:#777">//根据配置总线中解析计算闲置超时时长</span>
            <span style="color:#339;font-weight:bold">int</span> idleTimeout = getIdleTimeout(url);
            <span style="color:#339;font-weight:bold">long</span> heartbeatTimeoutTick = calculateLeastDuration(idleTimeout);
            <span style="color:#950">this</span>.reconnectTimerTask = <span style="color:#080;font-weight:bold">new</span> ReconnectTimerTask(cp, heartbeatTimeoutTick, idleTimeout);
            IDLE_CHECK_TIMER.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, <span style="color:#0a8;font-weight:bold">TimeUnit</span>.MILLISECONDS);
        }
    }


...
}


<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeaderExchangeServer</span> <span style="color:#088;font-weight:bold">implements</span> ExchangeServer {
...
    private <span style="color:#339;font-weight:bold">void</span> startIdleCheckTask(<span style="color:#0a8;font-weight:bold">URL</span> url) {
        <span style="color:#080;font-weight:bold">if</span> (!server.canHandleIdle()) {
            AbstractTimerTask.ChannelProvider cp = () -&gt;
                unmodifiableCollection(HeaderExchangeServer.this.getChannels());

            <span style="color:#339;font-weight:bold">int</span> idleTimeout = getIdleTimeout(url);
            <span style="color:#339;font-weight:bold">long</span> idleTimeoutTick = calculateLeastDuration(idleTimeout);
            CloseTimerTask closeTimerTask = <span style="color:#080;font-weight:bold">new</span> CloseTimerTask(cp, idleTimeoutTick, idleTimeout);
            <span style="color:#950">this</span>.closeTimerTask = closeTimerTask;

            <span style="color:#777">// init task and start timer.</span>
            IDLE_CHECK_TIMER.newTimeout(closeTimerTask, idleTimeoutTick, <span style="color:#0a8;font-weight:bold">TimeUnit</span>.MILLISECONDS);
        }
    }
...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 has-source-line data-line-stdin-424">
<h2 id="_具体实现细节">具体实现细节</h2>
<div class="sectionbody">
<div class="sect2 has-source-line data-line-stdin-426">
<h3 id="_exchangechannel_headerexchangechannel">ExchangeChannel → HeaderExchangeChannel</h3>
<div class="paragraph has-source-line data-line-stdin-428">
<p><strong>ExchangeChannel</strong> 的实现方式是包装另外一个现成的Channel，除下述方法外，基本所有的行为都是直接委托给这个内嵌的Channel，包括通道本地变量
Attribute的存取、自身和对端的<code>InetSocketAddress</code>的获取、连接的状态获取、<code>getUrl()</code>等。当两个<strong>HeaderExchangeChannel</strong>实例中内嵌
Channel等同时，这两对象便彼此<code>equals()</code>。</p>
</div>
<div class="sect3 has-source-line data-line-stdin-432">
<h4 id="_初涉同步转异步">初涉同步转异步</h4>
<div class="paragraph has-source-line data-line-stdin-434">
<p>网络传输层中已提及，消息的传送是通过绑定到端和端的Channel通道完成的，在此基础上<strong>ExchangeChannel</strong>担负的同步转异步处理的职责，大致原理
是：</p>
</div>
<div class="olist arabic has-source-line data-line-stdin-437">
<ol class="arabic">
<li class="has-source-line data-line-stdin-437">
<p>先实例化一个持有<span class="small">该Channel通道、当前Request请求对象、超时时间</span>的<code>DefaultFuture→CompletableFuture</code>；</p>
</li>
<li class="has-source-line data-line-stdin-438">
<p>由内嵌Channel先完成正常的发送操作；</p>
</li>
<li class="has-source-line data-line-stdin-439">
<p>随后还没等到结果返回就给调用方返回<code>DefaultFuture&lt;Object&gt;</code>对象</p>
<div class="literalblock has-source-line data-line-stdin-441">
<div class="content">
<pre>DefaultFuture类中持有一个全局&lt;Long,DefaultFuture&gt;键值对Map</pre>
</div>
</div>
</li>
<li class="has-source-line data-line-stdin-443">
<p>该层中注册<code>ExchangeChannelHandler</code>在被回调<code>received(Channel, Object)</code>时，会从入站的Response响应解析得到会话ID，由其从Map中获取到
<code>DefaultFuture</code>实例对象</p>
</li>
<li class="has-source-line data-line-stdin-446">
<p>根据Response的状态选择调用<code>complete(T)</code>或<code>completeExceptionally(Throwable)</code>最终完成同步转异步的处理。</p>
</li>
</ol>
</div>
<div class="paragraph has-source-line data-line-stdin-448">
<p>上述简要说明了同步转异步的过程，具体细节不不止这么复杂，先有个概念，便于渐渐理解<code>Exchanger</code>这一框架层的实现。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-450">
<p>有关请求发送的实现代码如下，构建<code>Request</code>请求对象，将其封装在<code>DefaultFuture</code>中返回：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-453">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; request(<span style="color:#0a8;font-weight:bold">Object</span> request) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
    <span style="color:#080;font-weight:bold">return</span> request(request, channel.getUrl().
        getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT));
}

<span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; request(<span style="color:#0a8;font-weight:bold">Object</span> request, <span style="color:#339;font-weight:bold">int</span> timeout)
        <span style="color:#088;font-weight:bold">throws</span> RemotingException {

    <span style="color:#080;font-weight:bold">if</span> (closed) {
        <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> RemotingException(<span style="color:#950">this</span>.getLocalAddress(), <span style="color:#069">null</span>,
            <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Failed to send request </span><span style="color:#710">"</span></span> + request +
            <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, cause: The channel </span><span style="color:#710">"</span></span> + <span style="color:#950">this</span> + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> is closed!</span><span style="color:#710">"</span></span>);
    }
    <span style="color:#777">// create request.</span>
    Request req = <span style="color:#080;font-weight:bold">new</span> Request();
    req.setVersion(Version.getProtocolVersion());

    <span style="color:#777">//告知需要有响应返回</span>
    req.setTwoWay(<span style="color:#069">true</span>);

    <span style="color:#777">//将实际的请求内容包装在Request的mData字段中</span>
    req.setData(request);

    <span style="color:#777">//返回结果前，将Request封装在DefaultFuture中</span>
    DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout);
    <span style="color:#080;font-weight:bold">try</span> {

        <span style="color:#777">//调用内嵌传输层channel完成请求数据的发送操作，下述调用没有阻塞</span>
        channel.send(req);
    } <span style="color:#080;font-weight:bold">catch</span> (RemotingException e) {

        <span style="color:#777">//如果遇到异常，则调用CompletableFuture的cancel</span>
        future.cancel();
        <span style="color:#080;font-weight:bold">throw</span> e;
    }
    <span style="color:#080;font-weight:bold">return</span> future;
}</code></pre>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-495">
<h4 id="_close状态管理">close状态管理</h4>
<div class="paragraph has-source-line data-line-stdin-497">
<p>HeaderExchangeChannel中有一个比较特殊的<code>volatile boolean closed</code>类型的变量，该状态量和内嵌传输层的Channel通道实例中持有的互不相干，
它的存在仅服务于当前信息交换层，更多是为了给当前通道尚未收到结果的DefaultFuture来个优雅处理，确保它们正常完成或者超时结束后再关闭传输层的
Channel通道。这个实现依赖于DefaultFuture类中持有一个全局&lt;Long, Channel&gt;键值对Map，只要该Map中含有当前持有的传输层Channel，便需优雅close。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-503">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">volatile</span> <span style="color:#339;font-weight:bold">boolean</span> closed = <span style="color:#069">false</span>;


<span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">boolean</span> isClosed() {
    <span style="color:#080;font-weight:bold">return</span> closed;
}

<span style="color:#777">// graceful close</span>
<span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> close(<span style="color:#339;font-weight:bold">int</span> timeout) {
    <span style="color:#080;font-weight:bold">if</span> (closed) {
        <span style="color:#080;font-weight:bold">return</span>;
    }
    closed = <span style="color:#069">true</span>;
    <span style="color:#080;font-weight:bold">if</span> (timeout &gt; <span style="color:#00D">0</span>) {
        <span style="color:#339;font-weight:bold">long</span> start = <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis();
        <span style="color:#080;font-weight:bold">while</span> (DefaultFuture.hasFuture(channel)
                &amp;&amp; <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis() - start &lt; timeout) {
            <span style="color:#080;font-weight:bold">try</span> {
                <span style="color:#0a8;font-weight:bold">Thread</span>.sleep(<span style="color:#00D">10</span>);
            } <span style="color:#080;font-weight:bold">catch</span> (<span style="color:#C00;font-weight:bold">InterruptedException</span> e) {
                logger.warn(e.getMessage(), e);
            }
        }
    }
    close();
}</code></pre>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-535">
<h4 id="_创建方式">创建方式</h4>
<div class="paragraph has-source-line data-line-stdin-537">
<p>在网络传输层中介绍过因Channel属于一种专属I/O管控资源，需要对NettyChannel进行适当保护，防止被误用，限定其只能在当前包中使用，因而类的作用
域被声明为<code>default</code>的，构造函数也被声明为<code>private</code>，必须通过能够记录<code>&lt;io.netty.channel.Channel,NettyChannel&gt;</code>键值对关系的
<code>getOrAddChannel</code>创建。本质是由于NettyChannel的I/O通讯行为实现本非其本身，是委托给作为键的Channel完成的，之间存在一对一的强绑定关系。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-541">
<p>同样，<code>HeaderExchangeChannel</code>也存在一个类似的同名方法，不同的是它和Dubbo自身声明的<code>org.apache.dubbo.remoting.Channel</code>是一种依附
关系，高层对基层的依赖，因此在实现上，其绑定关系是直接使用后者的本地变量存取容器加以表达的。在当前层中的每一种I/O回调事件中，会先调用该方法确保
正处于活态的连入<strong>Channel</strong>绑入了<code>HeaderExchangeChannel</code>实例，它是确保<code>信息交换层</code>的职责得以体现的关键一环。当然I/O回调的最后无论
如何会调用<code>removeChannelIfDisconnected</code>，将已经失活的Channel的绑定关系移除。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-547">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Channel</span> channel;

HeaderExchangeChannel(<span style="color:#0a8;font-weight:bold">Channel</span> channel) {
    <span style="color:#080;font-weight:bold">if</span> (channel == <span style="color:#069">null</span>) {
        <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">IllegalArgumentException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">channel == null</span><span style="color:#710">"</span></span>);
    }
    <span style="color:#950">this</span>.channel = channel;
}

<span style="color:#777">//根据Channel创建需要绑定在其上对应的HeaderExchangeChannel</span>
<span style="color:#088;font-weight:bold">static</span> HeaderExchangeChannel getOrAddChannel(<span style="color:#0a8;font-weight:bold">Channel</span> ch) {
    <span style="color:#080;font-weight:bold">if</span> (ch == <span style="color:#069">null</span>) {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">null</span>;
    }
    HeaderExchangeChannel ret = (HeaderExchangeChannel) ch.getAttribute(CHANNEL_KEY);
    <span style="color:#080;font-weight:bold">if</span> (ret == <span style="color:#069">null</span>) {
        ret = <span style="color:#080;font-weight:bold">new</span> HeaderExchangeChannel(ch);

        <span style="color:#777">//如果Channel不存于连接激活态中，创建的HeaderExchangeChannel实例便会处于游离态中</span>
        <span style="color:#080;font-weight:bold">if</span> (ch.isConnected()) {
            ch.setAttribute(CHANNEL_KEY, ret);
        }
    }
    <span style="color:#080;font-weight:bold">return</span> ret;
}

<span style="color:#777">//根据本地变量容器中的Channel移除对应的HeaderExchangeChannel</span>
<span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> removeChannelIfDisconnected(<span style="color:#0a8;font-weight:bold">Channel</span> ch) {
    <span style="color:#080;font-weight:bold">if</span> (ch != <span style="color:#069">null</span> &amp;&amp; !ch.isConnected()) {
        ch.removeAttribute(CHANNEL_KEY);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 has-source-line data-line-stdin-582">
<h3 id="_headerexchangeclient_exchangeclient">HeaderExchangeClient → ExchangeClient</h3>
<div class="paragraph has-source-line data-line-stdin-584">
<p>如传输层的NettyClient实现，HeaderExchangeClient也实现了<code>HeaderExchangeChannel</code>接口，后者扩展自Channel这个基础接口，也就是说他的行为
同样最终是委托给<code>HeaderExchangeChannel</code>完成的。使用实现接口代替组合引用，可以直接利用委托模式给外界提供便利的访问接口，也更加准确的描述了
Client和Channel严格的一一对应关系，后者于前者而言是一种强依赖存在。</p>
</div>
<div class="imageblock has-source-line data-line-stdin-588">
<div class="content">
<img src="res_files/imgs/6_image(2)" alt="Dubbo Exchange UML" width="650">
</div>
<div class="title">图：Dubbo Exchange UML</div>
</div>
<div class="paragraph has-source-line data-line-stdin-590">
<p>在其基础能力已被<code>HeaderExchangeChannel</code>实现的基础上，如上文所述Client需要负责：1）维持其绑定Channel通道和对端Server的长连状态；2）
在因自身故障掉线后采取重连处理。因而它的侧重点是定时轮资源的分配、定时任务的创建和取消。定时轮实际上是一个维持了单一线程的周期任务调度器，在Java
中线程是一种宝贵的资源，并非每个Client都能独享一份，因此同一个JVM内所有Client共享一个全局的定时轮实例。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-596">
<p>注：<span class="small">同一Jvm中的所有Server实例也是共享一个定时轮实例，不和Client共用的原因是有些应用使用了Dubbo的客户端访问其他服务资源，但并不对外
提供服务，反过来提供服务的Dubbo应用也不一定会拥有需要访问Dubbo服务的Client实例。</span></p>
</div>
<div class="listingblock has-source-line data-line-stdin-600">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeaderExchangeClient</span> <span style="color:#088;font-weight:bold">implements</span> ExchangeClient {

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> Client client;
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> ExchangeChannel channel;

    <span style="color:#777">//定时轮所有Client共享一份</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span style="color:#080;font-weight:bold">new</span> HashedWheelTimer(
            <span style="color:#080;font-weight:bold">new</span> NamedThreadFactory(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">dubbo-client-idleCheck</span><span style="color:#710">"</span></span>, <span style="color:#069">true</span>), <span style="color:#00D">1</span>, <span style="color:#0a8;font-weight:bold">TimeUnit</span>.SECONDS, TICKS_PER_WHEEL);

    <span style="color:#777">//保持长连的心跳检测任务和重连任务是每个Client实例都独有的，互不干扰</span>
    <span style="color:#088;font-weight:bold">private</span> HeartbeatTimerTask heartBeatTimerTask;
    <span style="color:#088;font-weight:bold">private</span> ReconnectTimerTask reconnectTimerTask;

    <span style="color:#088;font-weight:bold">public</span> HeaderExchangeClient(Client client, <span style="color:#339;font-weight:bold">boolean</span> startTimer) {
        Assert.notNull(client, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Client can't be null</span><span style="color:#710">"</span></span>);
        <span style="color:#950">this</span>.client = client;

        <span style="color:#777">//client实现了Channel接口</span>
        <span style="color:#950">this</span>.channel = <span style="color:#080;font-weight:bold">new</span> HeaderExchangeChannel(client);

        <span style="color:#080;font-weight:bold">if</span> (startTimer) {
            <span style="color:#777">//标识启用定时轮的情况下，每个Client实例初始化时启用周期任务执行重连和心跳处理</span>
            <span style="color:#0a8;font-weight:bold">URL</span> url = client.getUrl();
            startReconnectTask(url);
            startHeartBeatTask(url);
        }
    }
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; request(<span style="color:#0a8;font-weight:bold">Object</span> request) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        <span style="color:#777">//委托给ExchangeChannel完成请求</span>
        <span style="color:#080;font-weight:bold">return</span> channel.request(request);
    }

    ...

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> close() {
        doClose();
        channel.close();
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> close(<span style="color:#339;font-weight:bold">int</span> timeout) {
        <span style="color:#777">// Mark the client into the closure process</span>
        startClose();
        doClose();
        channel.close(timeout);
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">void</span> doClose() {
        <span style="color:#080;font-weight:bold">if</span> (heartBeatTimerTask != <span style="color:#069">null</span>) {
            heartBeatTimerTask.cancel();
        }

        <span style="color:#080;font-weight:bold">if</span> (reconnectTimerTask != <span style="color:#069">null</span>) {
            reconnectTimerTask.cancel();
        }
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> startClose() {
        channel.startClose();
    }
    ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note has-source-line data-line-stdin-669">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
在HeaderExchangeClient关闭执行资源回收之前，一定得先取消当前正在异步执行的定时任务，其周期性不间断的运行会导致资源的消耗。更糟糕的是通道
Channel已经关闭了，所有上述提到的周期任务都会执行网络I/O处理，必定会抛错，资源消耗相比更加严重。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2 has-source-line data-line-stdin-672">
<h3 id="_headerexchangeserver_exchangeserver">HeaderExchangeServer → ExchangeServer</h3>
<div class="paragraph has-source-line data-line-stdin-674">
<p>同<code>HeaderExchangeClient</code>一样，<code>HeaderExchangeServer</code>并没有直接继承自某个Server的实现<sub>比如NettyServer</sub>，而是使用组合的方式内置一个
<code>Server</code>引用，这样做的好处是并没有绑定传输层的某一种具体实现，可以根据需要灵活的组合传输层的具体Server实现，不至于产生类爆炸的现象，保持
了框架的精炼简洁。因而，扩展自Server接口部分的行为大多都委托给了所引用的Server实例。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-678">
<p>上文中已经提及<code>Exchanger框架层</code>的Server为了避免资源消耗，需要周期性的检测是否有连入Client因为宕机等原因已经掉线，若掉线则将其清除出去，
具体应用和原理已经介绍，这里不再赘述。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-681">
<p>和<code>HeaderExchangeClient</code>不同的是，Server端是被多个Client接入的，因而其状态维护就变得比较关键：</p>
</div>
<div class="olist arabic has-source-line data-line-stdin-683">
<ol class="arabic">
<li class="has-source-line data-line-stdin-683">
<p>在关闭之前先得检测是否还有处于活动态的；</p>
</li>
<li class="has-source-line data-line-stdin-684">
<p>连入Channel通道，处于正在关闭的过程中时，需要及时知会所有接入Client，自己不再接受写操作；</p>
</li>
<li class="has-source-line data-line-stdin-685">
<p>一旦启用关闭操作，作为服务提供方，后续便不能再往外向所有连入Client发送除ReadOnly事件的任何信息；</p>
</li>
</ol>
</div>
<div class="paragraph has-source-line data-line-stdin-687">
<p>具体如下源码：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-690">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeaderExchangeServer</span> <span style="color:#088;font-weight:bold">implements</span> ExchangeServer {

    使用原子变量<span style="color:#F00;background-color:#FAA">，</span>确保并发时<span style="color:#F00;background-color:#FAA">，</span>第一时间获知当前的关闭状态
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">AtomicBoolean</span> closed = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">AtomicBoolean</span>(<span style="color:#069">false</span>);

...


    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">boolean</span> isClosed() {
        <span style="color:#080;font-weight:bold">return</span> server.isClosed();
    }

    <span style="color:#777">//只要还有一个活动态的连入Channel通道，便认为Server还处于运行态</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">boolean</span> isRunning() {
        <span style="color:#0a8;font-weight:bold">Collection</span>&lt;<span style="color:#0a8;font-weight:bold">Channel</span>&gt; channels = getChannels();
        <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">Channel</span> channel : channels) {

            <span style="color:#777">/**
             *  If there are any client connections,
             *  our server should be running.
             */</span>

            <span style="color:#080;font-weight:bold">if</span> (channel.isConnected()) {
                <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">true</span>;
            }
        }
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">false</span>;
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> close() {
        doClose();
        server.close();
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> close(<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">int</span> timeout) {
        startClose();
        <span style="color:#080;font-weight:bold">if</span> (timeout &gt; <span style="color:#00D">0</span>) {
            <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">long</span> max = (<span style="color:#339;font-weight:bold">long</span>) timeout;
            <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">long</span> start = <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis();

            <span style="color:#777">//只读消息的发送与否取决于Server端的总线配置</span>
            <span style="color:#080;font-weight:bold">if</span> (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, <span style="color:#069">true</span>)) {
                sendChannelReadOnlyEvent();
            }

            <span style="color:#777">//超时内，只要还有Client没有断连，则继续等待</span>
            <span style="color:#080;font-weight:bold">while</span> (HeaderExchangeServer.this.isRunning()
                    &amp;&amp; <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis() - start &lt; max) {
                <span style="color:#080;font-weight:bold">try</span> {
                    <span style="color:#0a8;font-weight:bold">Thread</span>.sleep(<span style="color:#00D">10</span>);
                } <span style="color:#080;font-weight:bold">catch</span> (<span style="color:#C00;font-weight:bold">InterruptedException</span> e) {
                    logger.warn(e.getMessage(), e);
                }
            }
        }

        <span style="color:#777">//取消当前闲置检测周期任务</span>
        doClose();
        server.close(timeout);
    }

    <span style="color:#777">//大部分行为都委托给内置的server实例完成</span>
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> startClose() {
        server.startClose();
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">void</span> sendChannelReadOnlyEvent() {

        <span style="color:#777">//构建只读消息请求，不再接受写请求，无需响应</span>
        Request request = <span style="color:#080;font-weight:bold">new</span> Request();
        request.setEvent(Request.READONLY_EVENT);
        request.setTwoWay(<span style="color:#069">false</span>);
        request.setVersion(Version.getProtocolVersion());

        <span style="color:#777">//获取所有连入的处于已连接状态的通道Channel，挨个发送只读消息</span>
        <span style="color:#0a8;font-weight:bold">Collection</span>&lt;<span style="color:#0a8;font-weight:bold">Channel</span>&gt; channels = getChannels();
        <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">Channel</span> channel : channels) {
            <span style="color:#080;font-weight:bold">try</span> {
                <span style="color:#080;font-weight:bold">if</span> (channel.isConnected()) {
                    channel.send(request, getUrl().getParameter(
                        Constants.CHANNEL_READONLYEVENT_SENT_KEY, <span style="color:#069">true</span>));
                }
            } <span style="color:#080;font-weight:bold">catch</span> (RemotingException e) {
                logger.warn(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">send cannot write message error.</span><span style="color:#710">"</span></span>, e);
            }
        }
    }

    <span style="color:#777">//由成功执行原子变量closed改写的线程取消任务</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">void</span> doClose() {
        <span style="color:#080;font-weight:bold">if</span> (!closed.compareAndSet(<span style="color:#069">false</span>, <span style="color:#069">true</span>)) {
            <span style="color:#080;font-weight:bold">return</span>;
        }
        cancelCloseTask();
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">void</span> cancelCloseTask() {
        <span style="color:#080;font-weight:bold">if</span> (closeTimerTask != <span style="color:#069">null</span>) {
            closeTimerTask.cancel();
        }
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> reset(<span style="color:#0a8;font-weight:bold">URL</span> url) {
        server.reset(url);
        <span style="color:#080;font-weight:bold">try</span> {
            <span style="color:#777">//getUrl()获取的是当前Server预制的配置值</span>
            <span style="color:#339;font-weight:bold">int</span> currHeartbeat = getHeartbeat(getUrl());
            <span style="color:#339;font-weight:bold">int</span> currIdleTimeout = getIdleTimeout(getUrl());

            <span style="color:#777">//配置总线url中获取的是动态置入的配置</span>
            <span style="color:#339;font-weight:bold">int</span> heartbeat = getHeartbeat(url);
            <span style="color:#339;font-weight:bold">int</span> idleTimeout = getIdleTimeout(url);

            <span style="color:#777">//如果重设入参的配置值和当前Server不一致，则先取消当前的闲置检测任务，</span>
            <span style="color:#777">//使用url入参重新刷</span>
            <span style="color:#080;font-weight:bold">if</span> (currHeartbeat != heartbeat || currIdleTimeout != idleTimeout) {
                cancelCloseTask();
                startIdleCheckTask(url);
            }
        } <span style="color:#080;font-weight:bold">catch</span> (<span style="color:#0a8;font-weight:bold">Throwable</span> t) {
            logger.error(t.getMessage(), t);
        }
    }

    <span style="color:#777">//Server被关闭后，便不能通过连入Channel通道往所有Client发送消息</span>
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> send(<span style="color:#0a8;font-weight:bold">Object</span> message, <span style="color:#339;font-weight:bold">boolean</span> sent) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        <span style="color:#080;font-weight:bold">if</span> (closed.get()) {
            <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> RemotingException(<span style="color:#950">this</span>.getLocalAddress(), <span style="color:#069">null</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Failed to send message </span><span style="color:#710">"</span></span> + message
                    + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, cause: The server </span><span style="color:#710">"</span></span> + getLocalAddress() + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> is closed!</span><span style="color:#710">"</span></span>);
        }
        server.send(message, sent);
    }


...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 has-source-line data-line-stdin-834">
<h2 id="_同步转异步实现">同步转异步实现</h2>
<div class="sectionbody">
<div class="paragraph has-source-line data-line-stdin-836">
<p>Dubbo中的同步转异步是在当前信息交换层中处理的，实现采用了<code>ChannelHandler</code>的网络I/O事件回调机制。5个事件中，任务最繁重的当属<code>sent</code>和
<code>received</code>，也是同步转异步的主战场。上面已经大概介绍了其实现过程，本章节将深入其实现细节。</p>
</div>
<div class="sect2 has-source-line data-line-stdin-839">
<h3 id="_了解defaultfuture">了解<code>DefaultFuture</code></h3>
<div class="paragraph has-source-line data-line-stdin-841">
<p><code>DefaultFuture</code>的底层实现是<code>CompletableFuture&lt;Object&gt;</code>，可初步认为后者是一个基于fork-join的异步多线程任务编排框架，有关其运作机制
及实现原理，将会在另外一篇文章独立展开，本章节只介绍其在<code>DefaultFuture</code>实现中的应用。</p>
</div>
<div class="sect3 has-source-line data-line-stdin-844">
<h4 id="_场景分析">场景分析</h4>
<div class="paragraph has-source-line data-line-stdin-846">
<p>端到端的网络通讯行为几乎绝大部分场景都发生在两台主机间，可能相距千里，即便在同一台主机的两个进程间，分属于不同的JVM实例，如果不是收到彼端主动
推送过来的信息，此端没有任何途径感知彼端发生了什么。而网络通讯是个复杂的过程，异常是几乎不可避免的，往往发生了，也就意味着收不到彼端传送过来
的消息了，归纳起来就是需要针对如下几种场景做异常处理：</p>
</div>
<div class="olist arabic has-source-line data-line-stdin-850">
<ol class="arabic">
<li class="has-source-line data-line-stdin-850">
<p>消息已准备好，经此端传输层发往对端的过程中，遇到故障抛出异常；</p>
</li>
<li class="has-source-line data-line-stdin-851">
<p>消息经本地传输层发送出去后，网络传输过程中遇到异常；</p>
</li>
<li class="has-source-line data-line-stdin-852">
<p>发送消息后，成功抵达对端，彼端响应处理出现异常；</p>
</li>
<li class="has-source-line data-line-stdin-853">
<p>彼端成功处理响应，回传响应遇到异常；</p>
</li>
</ol>
</div>
<div class="paragraph has-source-line data-line-stdin-855">
<p>于第一种异常，由于属于同一JVM乃至同一线程内，普通的<code>try-catch</code>足够应对，第三种异常，Dubbo框架会负责捕获并回传相应的异常响应，也能妥善
应对。其它两种异常属于链路层异常，由于已没法感知到彼端，又不可能无限制的等下去，因此需要配合超时检测机制，一旦超时便在此端做超时响应处理。可
见，超时异常响应是由本机自发构造，这也确保了<code>CompletableFuture&lt;Object&gt;</code>不会长时间未被响应回调，客户端能得到及时反馈。</p>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-859">
<h4 id="_实现缘由">实现缘由</h4>
<div class="paragraph has-source-line data-line-stdin-861">
<p>也就是说<code>DefaultFuture</code>的业务职能核心是<strong>处理响应</strong>，包括正常响应、异常响应以及本机检测产生的超时响应。实现采用了<code>DefaultFuture</code>→
<code>CompletableFuture&lt;Object&gt;</code>，至于为什么，下面我们逐步撕开其面纱：</p>
</div>
<div class="exampleblock has-source-line data-line-stdin-864">
<div class="content">
<div class="olist arabic has-source-line data-line-stdin-866">
<ol class="arabic">
<li class="has-source-line data-line-stdin-866">
<p>Dubbo将重I/O操作的远程通讯委托给了诸如Netty等第三方中间件，效率、吞吐量、硬件利用率等的综合考量，往往它们会采用基于I/O多路复用机制甚至
异步方式实现，这也就意味着I/O就绪后会基于通知回调方式告知调用方，不会造成其阻塞；</p>
</li>
<li class="has-source-line data-line-stdin-868">
<p>基于通知回调方式的编程实际就是响应式编程，因任务编排比较困难或容易造成回调地狱，绝大部分习惯了直线思维的开发人员是没法适应这种编程方式的，
为迎合着绝大部分人，Dubbo使用了同步转异步方案；</p>
</li>
<li class="has-source-line data-line-stdin-870">
<p>在《Dubbo远程通讯 · 网络传输层》一文中已经已经提到过，当前Client使用在连的Netty Channel通道发出消息后便即刻返回，后续的响应<sub>包括异常响应</sub>
通过I/O回调才能获知;</p>
</li>
<li class="has-source-line data-line-stdin-872">
<p>当然如果配置总线传入了sent参数，便阻塞直到获得对方的响应，同样是效率的考量，Dubbo中这个参数不会被鼓励。当前信息交换框架层，相对而言
所涉代码粒度跨度相当大，一个能适应该场景的非阻塞实现方案不可或缺，最好是能够完美配合Netty的回调方式，还要不影响到传输层work线程的调度方式，
这些要求也就限制了几乎只能使用<code>CompletableFuture</code>：</p>
<div class="olist loweralpha has-source-line data-line-stdin-876">
<ol class="loweralpha" type="a">
<li class="has-source-line data-line-stdin-876">
<p>它不要求一定要有执行计算的主体部分，简单实例化后便可交给线程池，且不阻塞调用方；</p>
</li>
<li class="has-source-line data-line-stdin-877">
<p>可通过调用<code>complete()</code>或<code>completeExceptionally()</code>将直接给result赋值调度完成该<code>Future</code>；</p>
</li>
<li class="has-source-line data-line-stdin-878">
<p>正常或异常响应结果可通过<code>whenComplete()</code>回调感知到；</p>
</li>
</ol>
</div>
</li>
<li class="has-source-line data-line-stdin-880">
<p>随之而来的问题是，对于一个通讯往来，调用方调用<code>Channel.send()</code>后便即刻返回，同时它需要持有<code>CompletableFuture</code>实例获取处理结果，
而该实例结果完成处理是有<code>ChannelHandler</code>I/O回调负责，但后者始终是针对Channel做回调处理的，一句话“<code>ChannelHandler</code>怎么根据
<code>Channel</code>获取到<code>CompletableFuture</code>实例”？</p>
</li>
<li class="has-source-line data-line-stdin-884">
<p>对应关系通过<code>&lt;Channel,CompletableFuture&gt;</code>表示？但是，通过在连的Channel通道发生的通讯往来并非只一个回合<sub>Request→Response</sub>，每一个
回合都需要维护一个的生命周期仅限于该回合的<code>CompletableFuture</code>实例，所幸一对<code>Request→Response</code>组合中共同持有一个全局单调唯一递增的
编号，因此上述对应关系需通过该ID编号间接关联；</p>
</li>
<li class="has-source-line data-line-stdin-888">
<p>回到<code>Channel</code>和<code>CompletableFuture</code>的对应关系上，很显然，是一对多的，因此依后者来管理这种关系是最合适的，但为什么不使用组合和使用继承
扩展方案，并且只覆写了<code>cancel()</code>这么一个方法？</p>
</li>
<li class="has-source-line data-line-stdin-891">
<p>使用继承不必实例化多个相关实例<sub>CompletableFuture和及上述关系管理类</sub>，与其生命周期紧密相随的内容更容易被管理，用完便扔，不用手动清理，由
垃圾收集器根据需要负责清理。至于为啥要覆写<code>cancel()</code>，API文档中的如下一段话，也许能解释为什么<sub>Dubbo的protocol协议层印证了这一点</sub>，大概
意思是如果其被调用了，那么依赖它的未完成<code>CompletableFuture</code>实例会被异常完成处理，如下：</p>
</li>
</ol>
</div>
<div class="quoteblock has-source-line data-line-stdin-895">
<blockquote>
<div class="paragraph has-source-line data-line-stdin-897">
<p>If not already completed, completes this CompletableFuture with a CancellationException. Dependent CompletableFutures that
 have not already completed will also complete exceptionally, with a CompletionException caused by this CancellationException.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-903">
<h4 id="_源码分析">源码分析</h4>
<div class="paragraph has-source-line data-line-stdin-905">
<p>由上文分析得知，在同步转异步的过程中，<code>DefaultFuture</code>的业务职能核心是<strong>处理响应</strong>，需要负责管理协同和Channel的关系，还要启用定时轮算
法检测超时任务。</p>
</div>
<div class="sect4 has-source-line data-line-stdin-908">
<h5 id="_关系维护">关系维护</h5>
<div class="paragraph has-source-line data-line-stdin-910">
<p>从上述分析中得出其生命周期只限于一个<code>Request→Response</code>往来这个过程，<code>DefaultFuture</code>是在Request实例诞生时得以构建的，随其消亡。更宏观
方面是，需要使用静态内部变量全局地维护实例<code>Channel</code>到<code>CompletableFuture</code>的关系，以便<code>ChannelHandler</code>执行I/O事件回调时通过前者
获取到后者，当然如上述，这是间接的。尽管<code>Request</code>的生命周期可能很短，但是于整个JVM内，二者关系依然时刻可能都是一对多的，请求可以并发地发
送出去。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-916">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">DefaultFuture</span> <span style="color:#088;font-weight:bold">extends</span> CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; {

    <span style="color:#777">//dubbo中的请求发送是允许并发的</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#0a8;font-weight:bold">Long</span>, <span style="color:#0a8;font-weight:bold">Channel</span>&gt; CHANNELS = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ConcurrentHashMap</span>&lt;&gt;();

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#0a8;font-weight:bold">Long</span>, DefaultFuture&gt; FUTURES = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ConcurrentHashMap</span>&lt;&gt;();

    <span style="color:#777">// invoke id.</span>
    <span style="color:#777">// 从request中获取，作为属性出现，便于使用</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Long</span> id;

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Channel</span> channel;

    <span style="color:#777">//Request和当前DefaultFuture是一对一的关系</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> Request request;

    <span style="color:#088;font-weight:bold">private</span> DefaultFuture(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Request request, <span style="color:#339;font-weight:bold">int</span> timeout) {
        <span style="color:#950">this</span>.channel = channel;
        <span style="color:#950">this</span>.request = request;
        <span style="color:#950">this</span>.id = request.getId();

        ...

        <span style="color:#777">// put into waiting map.</span>
        FUTURES.put(id, <span style="color:#950">this</span>);
        CHANNELS.put(id, channel);
    }


    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> DefaultFuture getFuture(<span style="color:#339;font-weight:bold">long</span> id) {
        <span style="color:#080;font-weight:bold">return</span> FUTURES.get(id);
    }

    <span style="color:#777">//因Future是同Channel一起加入的，因此可以通过Channel是</span>
    <span style="color:#777">//  否在关系对中得出是否存在对应future的结论</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">boolean</span> hasFuture(<span style="color:#0a8;font-weight:bold">Channel</span> channel) {
        <span style="color:#080;font-weight:bold">return</span> CHANNELS.containsValue(channel);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4 has-source-line data-line-stdin-957">
<h5 id="_消息已发确认">消息已发确认</h5>
<div class="paragraph has-source-line data-line-stdin-959">
<p>传输层在确认信息成功发送后，会立马回调注册ChannelHandler的<code>sent(Channel, Object)</code>方法通知这一消息。DefaultFuture中持有一个内存可见
的volatile型的sent变量，在确认发送后改写该值，以便超时检测任务能及时知晓，有了这一依据超时检测任务便能及时判别异常发生在此端还是彼端了(
<span class="small">成功发送出去说明通讯链路是正常的，回传瞬间发生链路异常的概率很小，即便发生也同一认为是对端异常</span>)。<code>TimeoutCheckTask</code>由负责
检测超时的线程池分配线程调度，而获取DefaultFuture实例改写该状态值处于Netty视觉的work线程中，因此该标识属于共享资源，需要<code>volatile</code>标识。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-965">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">volatile</span> <span style="color:#339;font-weight:bold">long</span> sent;

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> sent(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Request request) {
        DefaultFuture future = FUTURES.get(request.getId());
        <span style="color:#080;font-weight:bold">if</span> (future != <span style="color:#069">null</span>) {
            future.doSent();
        }
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">boolean</span> isSent() {
        <span style="color:#080;font-weight:bold">return</span> sent &gt; <span style="color:#00D">0</span>;
    }


    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">void</span> doSent() {
        sent = <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis();
    }</code></pre>
</div>
</div>
</div>
<div class="sect4 has-source-line data-line-stdin-985">
<h5 id="_超时检测">超时检测</h5>
<div class="paragraph has-source-line data-line-stdin-987">
<p>依然超时检测离不开时钟轮的支持，同样也是使用全局专用的名为<code>TIME_OUT_TIMER</code>单一<code>Timer</code>实例，每一个DefaultFuture实例都拥有一个超时检
测任务，任务随DefaultFuture一起实例化。需要注意的这里使用的<code>TimeoutCheckTask</code>实例承载的是一次性任务，因此运行完后便不可能再被使用。</p>
</div>
<div class="admonitionblock note has-source-line data-line-stdin-991">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
调用Timeout实例的<code>cancel()</code>方法会将自身取消，被装入定时轮的<code>cancelledTimeouts</code>队列中，待时钟引擎进入下一个滴答时刻将其移除，也就是
任务被取消
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock has-source-line data-line-stdin-994">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">DefaultFuture</span> <span style="color:#088;font-weight:bold">extends</span> CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; {

    <span style="color:#777">//超时检测时间轮，每一个ticket周期为30ms</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Timer</span> TIME_OUT_TIMER = <span style="color:#080;font-weight:bold">new</span> HashedWheelTimer(
            <span style="color:#080;font-weight:bold">new</span> NamedThreadFactory(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">dubbo-future-timeout</span><span style="color:#710">"</span></span>, <span style="color:#069">true</span>),
            <span style="color:#00D">30</span>,
            <span style="color:#0a8;font-weight:bold">TimeUnit</span>.MILLISECONDS);

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">long</span> start = <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis();

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">int</span> timeout;

    <span style="color:#777">// 每一个DefaultFuture拥有一个超时检测任务</span>
    <span style="color:#088;font-weight:bold">private</span> Timeout timeoutCheckTask;

    <span style="color:#088;font-weight:bold">private</span> DefaultFuture(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Request request, <span style="color:#339;font-weight:bold">int</span> timeout) {
        ...

        <span style="color:#777">//默认设置的超时为1s，超时时间可以直接传入，或者从Channel通道关联配置总线中获取</span>
        this.timeout = timeout &gt; <span style="color:#00D">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);

        ...
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">int</span> getTimeout() {
        <span style="color:#080;font-weight:bold">return</span> timeout;
    }

    <span style="color:#777">/**
     * check time out of the future
     */</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> timeoutCheck(DefaultFuture future) {
        TimeoutCheckTask task = <span style="color:#080;font-weight:bold">new</span> TimeoutCheckTask(future.getId());
        future.timeoutCheckTask = TIME_OUT_TIMER.newTimeout(task, future.getTimeout(), <span style="color:#0a8;font-weight:bold">TimeUnit</span>.MILLISECONDS);
    }

    <span style="color:#777">/**
     * init a DefaultFuture
     * 1.init a DefaultFuture
     * 2.timeout check
     *
     * @param channel channel
     * @param request the request
     * @param timeout timeout
     * @return a new DefaultFuture
     */</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> DefaultFuture newFuture(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Request request, <span style="color:#339;font-weight:bold">int</span> timeout) {
        <span style="color:#088;font-weight:bold">final</span> DefaultFuture future = <span style="color:#080;font-weight:bold">new</span> DefaultFuture(channel, request, timeout);
        <span style="color:#777">// timeout check</span>
        timeoutCheck(future);
        <span style="color:#080;font-weight:bold">return</span> future;
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> getTimeoutMessage(<span style="color:#339;font-weight:bold">boolean</span> scan) {
        <span style="color:#339;font-weight:bold">long</span> nowTimestamp = <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis();
        <span style="color:#080;font-weight:bold">return</span> (sent &gt; <span style="color:#00D">0</span> ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Waiting server-side response timeout</span><span style="color:#710">"</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Sending request timeout in client-side</span><span style="color:#710">"</span></span>)
                + (scan ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> by scan timer</span><span style="color:#710">"</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#710">"</span></span>) + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">. start time: </span><span style="color:#710">"</span></span>
                + (<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">SimpleDateFormat</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">yyyy-MM-dd HH:mm:ss.SSS</span><span style="color:#710">"</span></span>).format(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>(start))) + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, end time: </span><span style="color:#710">"</span></span>
                + (<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">SimpleDateFormat</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">yyyy-MM-dd HH:mm:ss.SSS</span><span style="color:#710">"</span></span>).format(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>())) + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">,</span><span style="color:#710">"</span></span>
                + (sent &gt; <span style="color:#00D">0</span> ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> client elapsed: </span><span style="color:#710">"</span></span> + (sent - start)
                + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> ms, server elapsed: </span><span style="color:#710">"</span></span> + (nowTimestamp - sent)
                : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> elapsed: </span><span style="color:#710">"</span></span> + (nowTimestamp - start)) + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> ms, timeout: </span><span style="color:#710">"</span></span>
                + timeout + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> ms, request: </span><span style="color:#710">"</span></span> + request + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, channel: </span><span style="color:#710">"</span></span> + channel.getLocalAddress()
                + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> -&gt; </span><span style="color:#710">"</span></span> + channel.getRemoteAddress();
    }

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">TimeoutCheckTask</span> <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a8;font-weight:bold">TimerTask</span> {

        <span style="color:#777">//记录Request的编号ID，间接关联DefaultFuture实例</span>
        <span style="color:#777">// 实际上也可以直接关联</span>
        <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Long</span> requestID;

        TimeoutCheckTask(<span style="color:#0a8;font-weight:bold">Long</span> requestID) {
            <span style="color:#950">this</span>.requestID = requestID;
        }

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> run(Timeout timeout) {
            DefaultFuture future = DefaultFuture.getFuture(requestID);
            <span style="color:#777">//当前任务是一次性的，因此如果没有找到对应的future或者future已经完成，</span>
            <span style="color:#777">// 立马返回后会被定时轮移除掉</span>
            <span style="color:#080;font-weight:bold">if</span> (future == <span style="color:#069">null</span> || future.isDone()) {
                <span style="color:#080;font-weight:bold">return</span>;
            }

            <span style="color:#777">// 构造异常请求</span>
            <span style="color:#777">// create exception response.</span>
            Response timeoutResponse = <span style="color:#080;font-weight:bold">new</span> Response(future.getId());
            <span style="color:#777">// set timeout status.</span>
            timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);
            timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span style="color:#069">true</span>));

            <span style="color:#777">//最后一个为true的timeout参数，告知当前是超时检测任务，由于任务已经执行完，无需再执行任务的取消操作</span>
            <span style="color:#777">// handle response.</span>
            DefaultFuture.received(future.getChannel(), timeoutResponse, <span style="color:#069">true</span>);

        }
    }
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4 has-source-line data-line-stdin-1098">
<h5 id="_响应处理">响应处理</h5>
<div class="paragraph has-source-line data-line-stdin-1100">
<p>此端成功接收到对方的响应说明，一个通讯往来已经完成，相应DefaultFuture也该寿终正寝了，表示<code>Channel</code>到<code>CompletableFuture</code>的关系也需要
被解除。最后阶段需要构建Response对象，通过父类的<code>complete()</code>通知上层调用方正常处理结果，或者调用completeExceptionally通知异常完成。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-1103">
<p>覆写的<code>cancel()</code>方法中构造了一个<code>Response</code>对象，表明当前请求也许允许此端异常而被放弃。另外它没有调用<code>received</code>方法，而是在调用完
<code>doReceived</code>随即将关系解除，由于对应<code>DefaultFuture</code>实例已经不在<code>FUTURES</code>中，持有的定时任务启动运行后没有机会再次构造Response
重复通知实例持有方。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1108">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> received(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Response response) {
        received(channel, response, <span style="color:#069">false</span>);
    }

    <span style="color:#777">//timeout参数识别是否为超时检测任务中发起的对本方法的调用</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> received(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Response response, <span style="color:#339;font-weight:bold">boolean</span> timeout) {
        <span style="color:#080;font-weight:bold">try</span> {
            DefaultFuture future = FUTURES.remove(response.getId());
            <span style="color:#080;font-weight:bold">if</span> (future != <span style="color:#069">null</span>) {
                Timeout t = future.timeoutCheckTask;

                <span style="color:#777">//非来自超时检测任务的调用，由于当前任务已经完成，需要将其从定时轮中取消</span>
                <span style="color:#080;font-weight:bold">if</span> (!timeout) {
                    <span style="color:#777">// decrease Time</span>
                    t.cancel();
                }
                future.doReceived(response);
            } <span style="color:#080;font-weight:bold">else</span> {
                logger.warn(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">The timeout response finally returned at </span><span style="color:#710">"</span></span>
                        + (<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">SimpleDateFormat</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">yyyy-MM-dd HH:mm:ss.SSS</span><span style="color:#710">"</span></span>).format(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>()))
                        + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, response </span><span style="color:#710">"</span></span> + response
                        + (channel == <span style="color:#069">null</span> ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#710">"</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, channel: </span><span style="color:#710">"</span></span> + channel.getLocalAddress()
                        + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> -&gt; </span><span style="color:#710">"</span></span> + channel.getRemoteAddress()));
            }
        } <span style="color:#080;font-weight:bold">finally</span> {
            <span style="color:#777">//CHANNELS中，有可能多个ID关联着一个Channel，移除单个，并不会影响其他的</span>
            CHANNELS.remove(response.getId());
        }
    }

    <span style="color:#777">//通知持有当前``CompletableFuture&lt;Object&gt;``实例的调用方最终处理结果</span>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">void</span> doReceived(Response res) {
        <span style="color:#080;font-weight:bold">if</span> (res == <span style="color:#069">null</span>) {
            <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">IllegalStateException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">response cannot be null</span><span style="color:#710">"</span></span>);
        }
        <span style="color:#080;font-weight:bold">if</span> (res.getStatus() == Response.OK) {
            <span style="color:#950">this</span>.complete(res.getResult());
        } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT
                || res.getStatus() == Response.SERVER_TIMEOUT) {

            <span style="color:#950">this</span>.completeExceptionally(<span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">TimeoutException</span>(res.getStatus()
                == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));
        } <span style="color:#080;font-weight:bold">else</span> {
            <span style="color:#950">this</span>.completeExceptionally(<span style="color:#080;font-weight:bold">new</span> RemotingException(channel, res.getErrorMessage()));
        }
    }


    <span style="color:#777">//为了避免依赖当前对象的CompletableFuture实例因Cancel而被异常完成，覆写cancel方法</span>
    <span style="color:#777">// 同时覆写也在语义上符合Dubbo的需要</span>
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">boolean</span> cancel(<span style="color:#339;font-weight:bold">boolean</span> mayInterruptIfRunning) {
        Response errorResult = <span style="color:#080;font-weight:bold">new</span> Response(id);
        errorResult.setStatus(Response.CLIENT_ERROR);
        errorResult.setErrorMessage(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">request future has been canceled.</span><span style="color:#710">"</span></span>);
        <span style="color:#950">this</span>.doReceived(errorResult);
        FUTURES.remove(id);
        CHANNELS.remove(id);
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">true</span>;
    }

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> cancel() {
        <span style="color:#950">this</span>.cancel(<span style="color:#069">true</span>);
    }</code></pre>
</div>
</div>
<div class="admonitionblock note has-source-line data-line-stdin-1176">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
上述代码中，分别针对因本地异常主动放弃、本地超时或者彼端超时、任务正常响应构建了<code>Response</code>，但在通知<code>CompletableFuture</code>实例持有方
时，只有正常响应的<code>Response</code>被原样返回，其它两个场景均被解析了成对应的异常，尽管多了一层转换，但好处很明显，统一看待，编码更灵活方便，
保持了架构的干净整洁。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 has-source-line data-line-stdin-1180">
<h2 id="_headerexchangehandler">HeaderExchangeHandler</h2>
<div class="sectionbody">
<div class="admonitionblock important has-source-line data-line-stdin-1183">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
当前网络传输层的<code>HeaderExchangeHandler</code>并不是该层中<code>ExchangeHandler</code>的实现，其接口实现关系为<code>HeaderExchangeHandler →
ChannelHandlerDelegate → ChannelHandler</code>，也就是说它是一个普通的网络I/O事件监听器实现，而后者是一个多了两个扩展特性的接口：1）
<code><span class="samll">String telnet(Channel, String)</span></code>；2）<code><span class="samll">CompletableFuture&lt;Object&gt; reply(ExchangeChannel, Object)</span></code>。
前者使用组合的方式将后者作为属性元素纳入，在收到需要响应的入站请求时，会根据请求类型将流程转到后者两个方法中的一个。同时后者的具体实现大部分
集中在更高一级的Protocol协议层，<code>Request</code>对象在当前层被屏蔽，取其Object类型的<code>mData</code>作为reply的参数。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2 has-source-line data-line-stdin-1190">
<h3 id="_读写时间戳记录">读写时间戳记录</h3>
<div class="paragraph has-source-line data-line-stdin-1192">
<p>上文已经提到，为了无论在那种网络I/O中间件下，都能够支持客户端周期性地“检测是否掉线，若掉线则重连”，因此HeaderExchangeHandler在每次I/O回调时
都会执行记录最近读、写时间戳。结合上文“周期任务”，具体实现代码如下：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1195">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HeaderExchangeHandler</span> <span style="color:#088;font-weight:bold">implements</span> ChannelHandlerDelegate{

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> connected(<span style="color:#0a8;font-weight:bold">Channel</span> channel) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        channel.setAttribute(KEY_READ_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        channel.setAttribute(KEY_WRITE_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        ...
    }

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> disconnected(<span style="color:#0a8;font-weight:bold">Channel</span> channel) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        channel.setAttribute(KEY_READ_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        channel.setAttribute(KEY_WRITE_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        ...
    }

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> received(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Object</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        channel.setAttribute(KEY_READ_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        ...
    }

    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> sent(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Object</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        channel.setAttribute(KEY_WRITE_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 has-source-line data-line-stdin-1222">
<h3 id="_上层channel实例创建">上层Channel实例创建</h3>
<div class="paragraph has-source-line data-line-stdin-1224">
<p>另外，从上文中已经知道当前信息交换层和下一层所有几个关键组件均是一一对应关系，基本上该层的组件基于下层的实例使用组合方式创建。特殊点的是，支持异步
外发消息的ExchangeChannel，因其I/O行为是委托给第三方中间件完成的，当前应用在回调中被动完成业务逻辑，因此同<code>NettyChannel</code>一样，其实例创建
是由底层驱动更高一级的框架层完成的，“(io.netty).<strong>Channel</strong> → o.a.d.r.transport.<strong>NettyChannel</strong> → o.a.d.r.e.s.header.<strong>HeaderExchangeChannel</strong>”，
显然这个实例化操作只能在5个网络I/O回调方法中完成，由于通道Channel在一个“Request → Response往来”中，底层基本不会发生变化，因此会在当前框架层的<code>ChannelHandler</code>
的回调方法中创建<code>o.a.d.r.<strong>Channel</strong></code>实例，又因需要在每个I/O回调方法执行这一操作，不得不结合Map来确保只创建一个与底层Channel实例对应的该实例。
结合上文介绍过的<code>getOrAddChannel</code>和<code>removeChannelIfDisconnected</code>，统一视觉看之，实现细节中便有了如下的模板代码：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1231">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> XXX(<span style="color:#0a8;font-weight:bold">Channel</span> channel, ...) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
    ExchangeChannel exchangeChannel = HeaderExchangeChannel
        .getOrAddChannel(channel);

    <span style="color:#080;font-weight:bold">try</span> {
        handler.XXX(exchangeChannel, ...);
    } <span style="color:#080;font-weight:bold">finally</span> {
        HeaderExchangeChannel.removeChannelIfDisconnected(channel);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 has-source-line data-line-stdin-1245">
<h3 id="_入站数据处理">入站数据处理</h3>
<div class="paragraph has-source-line data-line-stdin-1247">
<p>入站的数据主要包括彼端发往此端的请求<strong>Request</strong>、响应<strong>Response</strong>、用于服务治理的纯String类型的<code>telnet</code>命令，前者又包含心跳请求、单向
请求、双向请求3种类型，如下：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1251">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> received(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Object</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        channel.setAttribute(KEY_READ_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        <span style="color:#088;font-weight:bold">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
        <span style="color:#080;font-weight:bold">try</span> {
            <span style="color:#080;font-weight:bold">if</span> (message <span style="color:#080;font-weight:bold">instanceof</span> Request) {
                <span style="color:#777">// handle request.</span>
                Request request = (Request) message;
                <span style="color:#080;font-weight:bold">if</span> (request.isEvent()) {
                    handlerEvent(channel, request);
                } <span style="color:#080;font-weight:bold">else</span> {
                    <span style="color:#080;font-weight:bold">if</span> (request.isTwoWay()) {
                        handleRequest(exchangeChannel, request);
                    } <span style="color:#080;font-weight:bold">else</span> {
                        <span style="color:#777">//单向Request无需Exchanger层继续处理，交由Transport信息传输层</span>
                        <span style="color:#777">// 做进一步处理</span>
                        handler.received(exchangeChannel, request.getData());
                    }
                }
            } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (message <span style="color:#080;font-weight:bold">instanceof</span> Response) {
                handleResponse(channel, (Response) message);
            } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (message <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">String</span>) {
                ... <span style="color:#777">//入站telnet命令处理</span>
            } <span style="color:#080;font-weight:bold">else</span> {
                <span style="color:#777">//非Dubbo实现的入站数据类型</span>
                handler.received(exchangeChannel, message);
            }
        } <span style="color:#080;font-weight:bold">finally</span> {
            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
        }
    }</code></pre>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-1285">
<h4 id="_入站响应处理">入站响应处理</h4>
<div class="paragraph has-source-line data-line-stdin-1287">
<p>上文已提及此端构建完请求使用Channel通道发送出去后就立即返回，调用方持有<code>DefaultFuture</code>实例，由Dubbo在网络I/O事件回调方法中通知其响应
已经抵达，也即调用<code>DefaultFuture.received</code>完成整个异步操作<span class="small">(complete <code>CompletableFuture</code>)</span>。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1291">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> handleResponse(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Response response) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
    <span style="color:#080;font-weight:bold">if</span> (response != <span style="color:#069">null</span> &amp;&amp; !response.isHeartbeat()) {
        DefaultFuture.received(channel, response);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-1299">
<h4 id="_入站事件处理">入站事件处理</h4>
<div class="paragraph has-source-line data-line-stdin-1300">
<p>入站的事件分为心跳、只读。这里只需要对后者加以处理，表示服务端正在关闭，告知客户端不再接受写操作，此时其Request请求对象中的mData属性值为“R”。
Client的内置Channel通道中的<code>CHANNEL_ATTRIBUTE_READONLY_KEY</code>本地属性值表示对应通往服务端的通道当前是否可正常使用，Dubbo会依据所有
本实例注册的Client中的这些值判别当前实例是否处于活跃态。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1304">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span style="color:#339;font-weight:bold">void</span> handlerEvent(<span style="color:#0a8;font-weight:bold">Channel</span> channel, Request req) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        <span style="color:#080;font-weight:bold">if</span> (req.getData() != <span style="color:#069">null</span> &amp;&amp; req.getData().equals(Request.READONLY_EVENT)) {
            channel.setAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY, <span style="color:#0a8;font-weight:bold">Boolean</span>.TRUE);
        }
    }

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">DubboInvoker</span>&lt;T&gt; <span style="color:#088;font-weight:bold">extends</span> AbstractInvoker&lt;T&gt;{


    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">boolean</span> isAvailable() {
        <span style="color:#080;font-weight:bold">if</span> (!<span style="color:#950">super</span>.isAvailable()) {
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">false</span>;
        }

        <span style="color:#777">//当所有client均不能执行写操作时，便认为DubboInvoker实例不可用</span>
        <span style="color:#080;font-weight:bold">for</span> (ExchangeClient client : clients) {
            <span style="color:#080;font-weight:bold">if</span> (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) {
                <span style="color:#777">//cannot write == not Available ?</span>
                <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">true</span>;
            }
        }
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">false</span>;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-1331">
<h4 id="_入站telnet命令处理">入站telnet命令处理</h4>
<div class="paragraph has-source-line data-line-stdin-1333">
<p>Dubbo支持使用telnet命令对服务端进行治理，但Client客户端是不支持的，因此入站数据为String类型时，需要判别当前是否为客户端。telnet命令支持
也是在Exchanger信息交换层完成的，<code>public interface ExchangeHandler extends ChannelHandler, TelnetHandler</code>。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1336">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">boolean</span> isClientSide(<span style="color:#0a8;font-weight:bold">Channel</span> channel) {
        <span style="color:#0a8;font-weight:bold">InetSocketAddress</span> address = channel.getRemoteAddress();
        <span style="color:#0a8;font-weight:bold">URL</span> url = channel.getUrl();
        <span style="color:#080;font-weight:bold">return</span> url.getPort() == address.getPort() &amp;&amp;
                NetUtils.filterLocalHost(url.getIp())
                        .equals(NetUtils.filterLocalHost(address.getAddress().getHostAddress()));
    }
    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> received(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Object</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
    {
        ...
        if (isClientSide(channel)) {
            <span style="color:#C00;font-weight:bold">Exception</span> e = <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">Exception</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Dubbo client can not supported string message: </span><span style="color:#710">"</span></span>
                    + message + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20"> in channel: </span><span style="color:#710">"</span></span> + channel + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, url: </span><span style="color:#710">"</span></span> + channel.getUrl());
            logger.error(e.getMessage(), e);
        } <span style="color:#080;font-weight:bold">else</span> {
            <span style="color:#0a8;font-weight:bold">String</span> echo = handler.telnet(channel, (<span style="color:#0a8;font-weight:bold">String</span>) message);
            <span style="color:#080;font-weight:bold">if</span> (echo != <span style="color:#069">null</span> &amp;&amp; echo.length() &gt; <span style="color:#00D">0</span>) {
                <span style="color:#777">//处理完telnet命令请求后，发回处理结果</span>
                channel.send(echo);
            }
        }
        ...
    }</code></pre>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-1366">
<h4 id="_初涉响应的同步转异步处理">初涉响应的同步转异步处理</h4>
<div class="paragraph has-source-line data-line-stdin-1368">
<p>上文中已经介绍过Dubbo中<code>DefaultFuture</code>是实现<code>“同步 → 异步”</code>的转换的关键支撑，主要是在网络I/O事件回调中根据当下响应状况构建响应
<code>Response</code>，而<code>HeaderExchangeChannel</code>则用于构建异步请求<code>Request</code>，同时获得一个<code>DefaultFuture</code>实例，便于调用方使用回调
获取到结果。然而对于如何将彼端发到此端的请求做异步处理，避免因上级业务层繁重的任务处理导致阻塞却未有涉及，显然入站请求的处理的切入点还是<code>
ChannelHandler.received(Channel, Object)</code>，这正是<code>HeaderExchangeHandler</code>的主要职责之一，当然仅限于收到的正常且需要发回响应
的<code>Request</code>。具体实现如下：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1375">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">void</span> handleRequest(<span style="color:#088;font-weight:bold">final</span> ExchangeChannel channel, Request req) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
    ...
    <span style="color:#777">//获取彼端的请求体</span>
    Object msg = req.getData();
    <span style="color:#080;font-weight:bold">try</span> {

        <span style="color:#777">//调用传入的ExchangeHandler实现的reply方法做响应处理</span>
        CompletionStage&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; future = handler.reply(channel, msg);

        <span style="color:#777">//上级应用层完成结果处理后，根据响应情况，构建正常或异常响应</span>
        future.whenComplete((appResult, t) -&gt; {
            <span style="color:#080;font-weight:bold">try</span> {
                <span style="color:#080;font-weight:bold">if</span> (t == <span style="color:#069">null</span>) {
                    res.setStatus(Response.OK);
                    res.setResult(appResult);
                } <span style="color:#080;font-weight:bold">else</span> {
                    res.setStatus(Response.SERVICE_ERROR);
                    res.setErrorMessage(StringUtils.toString(t));
                }

                <span style="color:#777">//在回调中使用底层通道Channel实现（NettyChannel）发回响应</span>
                channel.send(res);
            } <span style="color:#080;font-weight:bold">catch</span> (RemotingException e) {
                logger.warn(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Send result to consumer failed, channel is </span><span style="color:#710">"</span></span> + channel + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">, msg is </span><span style="color:#710">"</span></span> + e);
            } <span style="color:#080;font-weight:bold">finally</span> {
                <span style="color:#777">// HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span>
            }
        });
    } <span style="color:#080;font-weight:bold">catch</span> (<span style="color:#0a8;font-weight:bold">Throwable</span> e) {

        <span style="color:#777">//若上级应用层处理遇到异常，直接构建失败响应发送给彼端</span>
        res.setStatus(Response.SERVICE_ERROR);
        res.setErrorMessage(StringUtils.toString(e));
        channel.send(res);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-1414">
<h4 id="_解码失败的入站请求及异常响应">解码失败的入站请求及异常响应</h4>
<div class="paragraph has-source-line data-line-stdin-1416">
<p>网络交换过程中，始终存在一个二进制码流到Java实例数据转换的过程，也就是需要有编解码操作的存在，交换层负责将传输层的入站请求解码封装成<code>Request</code>
对象。如果解码失败，并不会直接采用抛错形式告知上级的调用方，而依然是封装成<code>Request</code>对象，设置<code>mBroken</code>为true，因此在<code>received</code>后
仅仅需要通过Channel通道发回异常响应便可。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-1420">
<p>同样，还有一种是由I/O中间件底层监视发现并驱动异常回调caught的情况，单向请求或者心跳事件都会被忽略。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1422">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">void</span> handleRequest(<span style="color:#088;font-weight:bold">final</span> ExchangeChannel channel, Request req)
        <span style="color:#088;font-weight:bold">throws</span> RemotingException {

    Response res = <span style="color:#080;font-weight:bold">new</span> Response(req.getId(), req.getVersion());
    <span style="color:#080;font-weight:bold">if</span> (req.isBroken()) {
        <span style="color:#0a8;font-weight:bold">Object</span> data = req.getData();

        <span style="color:#0a8;font-weight:bold">String</span> msg;
        <span style="color:#080;font-weight:bold">if</span> (data == <span style="color:#069">null</span>) {
            msg = <span style="color:#069">null</span>;
        } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (data <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Throwable</span>) {
            msg = StringUtils.toString((<span style="color:#0a8;font-weight:bold">Throwable</span>) data);
        } <span style="color:#080;font-weight:bold">else</span> {
            msg = data.toString();
        }
        res.setErrorMessage(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Fail to decode request due to: </span><span style="color:#710">"</span></span> + msg);
        res.setStatus(Response.BAD_REQUEST);

        channel.send(res);
        <span style="color:#080;font-weight:bold">return</span>;
    }
    ...
}

<span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> caught(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Throwable</span> exception) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
    <span style="color:#080;font-weight:bold">if</span> (exception <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#C00;font-weight:bold">ExecutionException</span>) {
        <span style="color:#C00;font-weight:bold">ExecutionException</span> e = (<span style="color:#C00;font-weight:bold">ExecutionException</span>) exception;
        <span style="color:#0a8;font-weight:bold">Object</span> msg = e.getRequest();
        <span style="color:#080;font-weight:bold">if</span> (msg <span style="color:#080;font-weight:bold">instanceof</span> Request) {
            Request req = (Request) msg;
            <span style="color:#080;font-weight:bold">if</span> (req.isTwoWay() &amp;&amp; !req.isHeartbeat()) {
                Response res = <span style="color:#080;font-weight:bold">new</span> Response(req.getId(), req.getVersion());
                res.setStatus(Response.SERVER_ERROR);
                res.setErrorMessage(StringUtils.toString(e));
                channel.send(res);
                <span style="color:#080;font-weight:bold">return</span>;
            }
        }
    }
    ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
    <span style="color:#080;font-weight:bold">try</span> {
        handler.caught(exchangeChannel, exception);
    } <span style="color:#080;font-weight:bold">finally</span> {
        HeaderExchangeChannel.removeChannelIfDisconnected(channel);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3 has-source-line data-line-stdin-1472">
<h4 id="_出站处理">出站处理</h4>
<div class="paragraph has-source-line data-line-stdin-1474">
<p>同样，出站的数据也包括了请求和响应，在同步转异步的实现中，<code>DefaultFuture</code>需要判别请求是否已经发送出去，以便超时检测出现超时时能告知调用
方超时是发生在此端还是彼端，这个操作时在<code>sent</code>网络I/O事件回调中完成的。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1478">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> sent(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">Object</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
    <span style="color:#777">//截获传入handler引发的异常</span>
    <span style="color:#0a8;font-weight:bold">Throwable</span> exception = <span style="color:#069">null</span>;
    <span style="color:#080;font-weight:bold">try</span> {
        channel.setAttribute(KEY_WRITE_TIMESTAMP, <span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis());
        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
        <span style="color:#080;font-weight:bold">try</span> {
            handler.sent(exchangeChannel, message);
        } <span style="color:#080;font-weight:bold">finally</span> {
            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
        }
    } <span style="color:#080;font-weight:bold">catch</span> (<span style="color:#0a8;font-weight:bold">Throwable</span> t) {
        exception = t;
    }
    <span style="color:#080;font-weight:bold">if</span> (message <span style="color:#080;font-weight:bold">instanceof</span> Request) {
        Request request = (Request) message;
        DefaultFuture.sent(channel, request);
    }

    <span style="color:#777">//将异常统一转换为RemotingException继续往上抛</span>
    <span style="color:#080;font-weight:bold">if</span> (exception != <span style="color:#069">null</span>) {
        <span style="color:#080;font-weight:bold">if</span> (exception <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#C00;font-weight:bold">RuntimeException</span>) {
            <span style="color:#080;font-weight:bold">throw</span> (<span style="color:#C00;font-weight:bold">RuntimeException</span>) exception;
        } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (exception <span style="color:#080;font-weight:bold">instanceof</span> RemotingException) {
            <span style="color:#080;font-weight:bold">throw</span> (RemotingException) exception;
        } <span style="color:#080;font-weight:bold">else</span> {
            <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> RemotingException(channel.getLocalAddress(),
                    channel.getRemoteAddress(),
                    exception.getMessage(), exception);
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 has-source-line data-line-stdin-1514">
<h2 id="_exchangehandler"><code>ExchangeHandler</code></h2>
<div class="sectionbody">
<div class="paragraph has-source-line data-line-stdin-1516">
<p>在上一章节中已经介绍过，当前网络传输层的核心职责是完成同步转异步的处理，异步发送到对方的请求表现在<code>ExchangeChannel</code>扩展通道接口上，是一
种主动行为，而异步发送响应给对方则表现在<code>ExchangeHandler</code>这个接口上，<code>ChannelHandler</code>的实现<code>HeaderExchangeHandler</code>在收到彼端
请求后，根据是否需要响应解析出Object类型的<code>mData</code>作为参数后将具体的应答业务操作委托给<code>ExchangeHandler</code>。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-1520">
<p><code>ExchangeHandler</code>接口定义如下：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1522">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">ExchangeHandler</span> <span style="color:#088;font-weight:bold">extends</span> ChannelHandler, TelnetHandler {

    <span style="color:#777">/**
     * reply.
     *
     * @param channel
     * @param request
     * @return response
     * @throws RemotingException
     */</span>
    CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; reply(ExchangeChannel channel, <span style="color:#0a8;font-weight:bold">Object</span> request) <span style="color:#088;font-weight:bold">throws</span> RemotingException;

}

<span style="color:#007">@SPI</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">TelnetHandler</span> {

    <span style="color:#777">/**
     * telnet.
     *
     * @param channel
     * @param message
     */</span>
    <span style="color:#0a8;font-weight:bold">String</span> telnet(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">String</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException;

}</code></pre>
</div>
</div>
<div class="sect2 has-source-line data-line-stdin-1551">
<h3 id="_replier_replierdispatcher"><code>Replier</code> &amp; <code>ReplierDispatcher</code></h3>
<div class="paragraph has-source-line data-line-stdin-1553">
<p><code>ExchangeHandler</code>实际上是为信息交换层提供了一个供上传直接调用的<code>reply(ExchangeChannel, Object)</code>方法，它屏蔽了本层的实现细节，连
<code>Request/Response</code>的存在也不会让其意识到。从<code>ExchangeHandler</code>来看，可以针对任意类型的request<sub>类型为Object</sub>做应答处理，也就是说
于使用同一个<code>o.a.d.r.Channel</code>通道进行信息交换的<code>Client ↔ Server</code>对而言，以面向对象编程的视觉来看，实际上隐含了<code>reply(ExchangeChannel, Object)</code>
方法可以应对各种不同数据类型的<code>request</code>入参的，也即可泛型化。因而Dubbo定义了如下的接口：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1558">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">Replier</span>&lt;T&gt; {

    <span style="color:#777">/**
     * reply.
     *
     * @param channel
     * @param request
     * @return response
     * @throws RemotingException
     */</span>
    <span style="color:#0a8;font-weight:bold">Object</span> reply(ExchangeChannel channel, T request)
            <span style="color:#088;font-weight:bold">throws</span> RemotingException;

}</code></pre>
</div>
</div>
<div class="paragraph has-source-line data-line-stdin-1574">
<p>从上述<code>reply()</code>方法可以看出，方法签名已经发生了变化，出参不再是<code>CompletableFuture&lt;Object&gt;</code>，也即当前层的异步被转换成了上层的同步。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-1576">
<p>为了应对这种<strong>泛型化</strong>，<span class="big"><em>派发器</em></span> 模型又再一次被搬上舞台，利用它来解决根据入参类型提供不同版本的<code>Replier</code>接口实现问题，框架层的
抽象层次更高，类结构更清晰，也化解了上层需要大量使用<code>IF-ELSE</code>的粗笨编码形式。</p>
</div>
<div class="paragraph has-source-line data-line-stdin-1579">
<p><strong>泛型化</strong>必然涉及到类型的处理，即需要提供<code>Class类型</code>到<code>Replier</code>接口实现的映射关系 <span class="small">Map&lt;Class&lt;?&gt;, Replier&lt;?&gt;&gt;</span>，由于
<code>Client ↔ Server</code>的信息交换是并发的，因而Dubbo使用了支持并发的<code>ConcurrentHashMap</code>作为其键值对容器，键值对关系不是强制需要的，
可以提供默认通用版本的实现，像最初，都当做Object对待。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1584">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">ReplierDispatcher</span> <span style="color:#088;font-weight:bold">implements</span> Replier&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; {

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> Replier&lt;?&gt; defaultReplier;

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#0a8;font-weight:bold">Class</span>&lt;?&gt;, Replier&lt;?&gt;&gt; repliers = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ConcurrentHashMap</span>&lt;<span style="color:#0a8;font-weight:bold">Class</span>&lt;?&gt;, Replier&lt;?&gt;&gt;();

    <span style="color:#088;font-weight:bold">public</span> ReplierDispatcher() {
        <span style="color:#950">this</span>(<span style="color:#069">null</span>, <span style="color:#069">null</span>);
    }

    <span style="color:#088;font-weight:bold">public</span> ReplierDispatcher(Replier&lt;?&gt; defaultReplier) {
        <span style="color:#950">this</span>(defaultReplier, <span style="color:#069">null</span>);
    }

    <span style="color:#088;font-weight:bold">public</span> ReplierDispatcher(Replier&lt;?&gt; defaultReplier, <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#0a8;font-weight:bold">Class</span>&lt;?&gt;, Replier&lt;?&gt;&gt; repliers) {
        <span style="color:#950">this</span>.defaultReplier = defaultReplier;
        <span style="color:#080;font-weight:bold">if</span> (repliers != <span style="color:#069">null</span> &amp;&amp; repliers.size() &gt; <span style="color:#00D">0</span>) {
            <span style="color:#950">this</span>.repliers.putAll(repliers);
        }
    }

    <span style="color:#088;font-weight:bold">public</span> &lt;T&gt; ReplierDispatcher addReplier(<span style="color:#0a8;font-weight:bold">Class</span>&lt;T&gt; type, Replier&lt;T&gt; replier) {
        repliers.put(type, replier);
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#950">this</span>;
    }

    <span style="color:#088;font-weight:bold">public</span> &lt;T&gt; ReplierDispatcher removeReplier(<span style="color:#0a8;font-weight:bold">Class</span>&lt;T&gt; type) {
        repliers.remove(type);
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#950">this</span>;
    }

    <span style="color:#088;font-weight:bold">private</span> Replier&lt;?&gt; getReplier(<span style="color:#0a8;font-weight:bold">Class</span>&lt;?&gt; type) {
        <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">Map</span>.Entry&lt;<span style="color:#0a8;font-weight:bold">Class</span>&lt;?&gt;, Replier&lt;?&gt;&gt; entry : repliers.entrySet()) {
            <span style="color:#080;font-weight:bold">if</span> (entry.getKey().isAssignableFrom(type)) {
                <span style="color:#080;font-weight:bold">return</span> entry.getValue();
            }
        }
        <span style="color:#080;font-weight:bold">if</span> (defaultReplier != <span style="color:#069">null</span>) {
            <span style="color:#080;font-weight:bold">return</span> defaultReplier;
        }
        <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">IllegalStateException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">Replier not found, Unsupported message object: </span><span style="color:#710">"</span></span> + type);
    }

    <span style="color:#007">@Override</span>
    <span style="color:#007">@SuppressWarnings</span>({<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">unchecked</span><span style="color:#710">"</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">rawtypes</span><span style="color:#710">"</span></span>})
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">Object</span> reply(ExchangeChannel channel, <span style="color:#0a8;font-weight:bold">Object</span> request) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        <span style="color:#080;font-weight:bold">return</span> ((Replier) getReplier(request.getClass())).reply(channel, request);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note has-source-line data-line-stdin-1639">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>ReplierDispatcher</code> 派发器只需要对一个Request做一次Response应答处理，是严格的一一对应关系，因此它不像本文涉及到的其它几个派发器，它是
单选的。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1 has-source-line data-line-stdin-1642">
<h2 id="_通道监听者派发器_exchangehandlerdispatcher">通道监听者派发器 <code>ExchangeHandlerDispatcher</code></h2>
<div class="sectionbody">
<div class="paragraph has-source-line data-line-stdin-1644">
<p>同传输层一样，信息交换层同样存在一个派发器<code>ExchangeHandlerDispatcher</code>，它是<code>ExchangeHandler</code>的装饰器实现，当然也是''ChannelHandler''
和''TelnetHandler''的装饰器实现，原因是<code>interface ExchangeHandler extends ChannelHandler, TelnetHandler</code>，因此它将5个基础
网络I/O事件回调委托给了更下层的<code>ChannelHandlerDispatcher</code>，因而具体实现上就会对应存在如下的模板方法：</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1648">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Override</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> XXX(<span style="color:#0a8;font-weight:bold">Channel</span> channel, ...) {
    handlerDispatcher.XXX(channel, ...);
}</code></pre>
</div>
</div>
<div class="paragraph has-source-line data-line-stdin-1654">
<p>更进一步而言，该派发器<code>ExchangeHandlerDispatcher</code>实际上是组合了<code>ChannelHandlerDispatcher</code>派发器，不止如此，它还组合了派发器
<code>ReplierDispatcher</code>和<code>TelnetHandler</code><sub><code>TelnetHandler</code>只有一种形式的存在，无需增加一个派发器实现</sub>。</p>
</div>
<div class="listingblock has-source-line data-line-stdin-1658">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">ExchangeHandlerDispatcher</span> <span style="color:#088;font-weight:bold">implements</span> ExchangeHandler {

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> ReplierDispatcher replierDispatcher;

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> ChannelHandlerDispatcher handlerDispatcher;

    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> TelnetHandler telnetHandler;

<span style="color:#777">//===========================</span>
<span style="color:#777">// 几个构造函数中，维telnetHandler一直无需变化</span>
<span style="color:#777">//===========================</span>
    <span style="color:#088;font-weight:bold">public</span> ExchangeHandlerDispatcher() {
        replierDispatcher = <span style="color:#080;font-weight:bold">new</span> ReplierDispatcher();
        handlerDispatcher = <span style="color:#080;font-weight:bold">new</span> ChannelHandlerDispatcher();
        telnetHandler = <span style="color:#080;font-weight:bold">new</span> TelnetHandlerAdapter();
    }

    <span style="color:#088;font-weight:bold">public</span> ExchangeHandlerDispatcher(Replier&lt;?&gt; replier) {
        replierDispatcher = <span style="color:#080;font-weight:bold">new</span> ReplierDispatcher(replier);
        handlerDispatcher = <span style="color:#080;font-weight:bold">new</span> ChannelHandlerDispatcher();
        telnetHandler = <span style="color:#080;font-weight:bold">new</span> TelnetHandlerAdapter();
    }

    <span style="color:#088;font-weight:bold">public</span> ExchangeHandlerDispatcher(ChannelHandler... handlers) {
        replierDispatcher = <span style="color:#080;font-weight:bold">new</span> ReplierDispatcher();
        handlerDispatcher = <span style="color:#080;font-weight:bold">new</span> ChannelHandlerDispatcher(handlers);
        telnetHandler = <span style="color:#080;font-weight:bold">new</span> TelnetHandlerAdapter();
    }

    <span style="color:#088;font-weight:bold">public</span> ExchangeHandlerDispatcher(Replier&lt;?&gt; replier, ChannelHandler... handlers) {
        replierDispatcher = <span style="color:#080;font-weight:bold">new</span> ReplierDispatcher(replier);
        handlerDispatcher = <span style="color:#080;font-weight:bold">new</span> ChannelHandlerDispatcher(handlers);
        telnetHandler = <span style="color:#080;font-weight:bold">new</span> TelnetHandlerAdapter();
    }

<span style="color:#777">//===========================</span>
<span style="color:#777">// 直接提供方法调用handlerDispatcher增删ChannelHandler实现</span>
<span style="color:#777">//===========================</span>
    <span style="color:#088;font-weight:bold">public</span> ExchangeHandlerDispatcher addChannelHandler(ChannelHandler handler) {
        handlerDispatcher.addChannelHandler(handler);
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#950">this</span>;
    }

    <span style="color:#088;font-weight:bold">public</span> ExchangeHandlerDispatcher removeChannelHandler(ChannelHandler handler) {
        handlerDispatcher.removeChannelHandler(handler);
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#950">this</span>;
    }

<span style="color:#777">//===========================</span>
<span style="color:#777">// 直接提供方法调用replierDispatcher增删Replier接口实现</span>
<span style="color:#777">//===========================</span>

    <span style="color:#088;font-weight:bold">public</span> &lt;T&gt; ExchangeHandlerDispatcher addReplier(<span style="color:#0a8;font-weight:bold">Class</span>&lt;T&gt; type, Replier&lt;T&gt; replier) {
        replierDispatcher.addReplier(type, replier);
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#950">this</span>;
    }

    <span style="color:#088;font-weight:bold">public</span> &lt;T&gt; ExchangeHandlerDispatcher removeReplier(<span style="color:#0a8;font-weight:bold">Class</span>&lt;T&gt; type) {
        replierDispatcher.removeReplier(type);
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#950">this</span>;
    }

    ...<span style="color:#777">// 其它5个类似模板方法的I/O事件回调</span>

    <span style="color:#007">@Override</span>
    <span style="color:#007">@SuppressWarnings</span>({<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">unchecked</span><span style="color:#710">"</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">"</span><span style="color:#D20">rawtypes</span><span style="color:#710">"</span></span>})
    <span style="color:#088;font-weight:bold">public</span> CompletableFuture&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt; reply(ExchangeChannel channel, <span style="color:#0a8;font-weight:bold">Object</span> request) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        <span style="color:#080;font-weight:bold">return</span> CompletableFuture.completedFuture(((Replier) replierDispatcher).reply(channel, request));
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">String</span> telnet(<span style="color:#0a8;font-weight:bold">Channel</span> channel, <span style="color:#0a8;font-weight:bold">String</span> message) <span style="color:#088;font-weight:bold">throws</span> RemotingException {
        <span style="color:#080;font-weight:bold">return</span> telnetHandler.telnet(channel, message);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note has-source-line data-line-stdin-1738">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>ExchangeHandlerDispatcher</code> 作为装饰器就是一个接口实现，它不是必须的，如果没有提供，自然就不需要运行包括<code>ReplierDispatcher</code>在内的
成套逻辑。
</td>
</tr>
</tbody></table>
</div>
<hr>
<div class="paragraph has-source-line data-line-stdin-1742">
<p>完结</p>
</div>
</div>
</div>
</div><script src="res_files/js/scrollToElement.js"></script>
<script src="res_files/js/processLinks.js"></script>
<script src="res_files/js/pickSourceLine.js"></script>
<script type="text/x-mathjax-config;executed=true">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
});
</script>
<script src="res_files/js/MathJax.js"></script>
<div id="color-picker-wrap" style="display: none; position: fixed; top: 0px; left: 0px; z-index: 9999;"><!----></div></body></html>